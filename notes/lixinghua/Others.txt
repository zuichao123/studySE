				封装性
this:代表当前对象
	如果一个类中有多个构造方法时，可以使用this关键字调用。
	在使用this关键字调用其他构造方法时：
		1.this()只能放在代码的首行；
		2.至少有一个构造方法是不用this()调用的，否则会出现构造方法递归调用。
		
static关键字：声明全局属性。
	最好实用类名调用。
	实用static不能调用非static的方法和属性。
		因为：static可以在对象没有实例化时就可以调用，而非static属性和方法，在实例化后才能被调用。

java中到底有多少个内存区域呢？
	1.栈内存：可以保持对象的名称（保存，访问的堆内存的地址）
	2.堆内存：保存每个对象的具体属性
	3.全局数据区：保存static类型的属性
	4.全局代码区：保存所有方法的定义

代码块：
	普通代码块；
		定义在方法中
	构造块；
		定义在类中；
		构造块优先于构造方法执行，且执行多次，只要一有实例化对象产生，就执行构造块中的内容。
	静态代码块：
		在主方法中定义的代码块；
		优先于主方法执行。只执行一次。
		
	静态块优先于主方法执行，如果在普通类中定义的静态块，优先于构造块执行，不管有多少个实例化对象产生，静态代码块只执行一次，静态代码块的主要功能就是为静态属性初始化。
	
构造方法私有化：单例模式：核心，就是将类的构造方法私有化，之后在类的内部产生实例化对象，并通过类的静态方法返回实例化对象的引用。
	的好处？
		1.对象唯一
		
对象数组：就是指包含了一组相关的对象，里面的每一个对象都是null值，使用时必须分别进行实例化操作。
	格式：类   对象数组名称[] = new 类[数组长度]
		Aa aa[] = new Aa[10];
		
内部类：编译后生成：外部类$内部类名称.class
	缺点：正常的一个类操作时，在类中最好只定义属性或方法。如果定义一个类的话，则肯定破坏了程序的一个结构。
	优点：可以方便的访问外部类中的私有属性。	
	
	使用static关键字定义内部类后，可以使用外部类名称.内部类名称来调用。
	
	一个内部类除了可以通过外部类访问，也可以直接在其他类中调用，格式：
		外部类.内部类   内部类对象 = 外部类实例.new 内部类();
		
	方法中定义内部类：如果该内部类要访问此方法的变量时，此变量必须定义为final。

链表：	
	增加节点是在链表的最后进行增加；
	查找节点就是依次递归的方式查找；
	删除节点，实际上就是改变引用传递的地址。
	
**********************************
			继承性	

继承：extends子类继承父类，扩展功能。
	通过super关键字，可以从子类访问父类中的内容。

	方法的重载与覆写的区别：
		重载：方法名相同，参数的类型或个数不同；对权限没有要求；发生在一个类中。
		覆写：方法名称、参数的类型、返回值类型全部相同；被覆写的方法不能拥有更严格的权限；反生在继承类中。
	
	不管任何时候，子类实例化对象时，默认先去调用父类中的无参构造方法，再调用子类的构方法。

this与super关键字的区别：
	this：
		属性访问：访问本类中的属性，如果本类没有此属性则从父类中继续查找；
		方法：访问本类中的方法，如果本类中没有此方法，则从父类中继续查找；
		调用构造：调用本类构造，必须放在构造方法的首行；
		特殊：表示当前对象。
	super：
		属性访问：访问父类中的属性；
		方法：直接访问父类中的方法；
		调用构造：调用父类构造，必须放在子类构造方法的首行；
		特殊：无此概念。
	this和super都可以调用构造方法，而且必须放在构造方法的首行，所以这两个关键字不能同时使用。

final关键字：
	可以使用final关键字声明类、属性、方法：
		使用final关键字声明的类不能有子类；
		使用final关键字声明的方法不能被子类所覆写；
		使用final关键字声明的变量即成为常量，常量不可以修改。
		
抽象类：
	包含一个抽象方法的类就称为抽象类；
	抽象类，不能被实例化；
	抽象类，必须有子类；子类必须覆写抽象类中的全部抽象方法。
	抽象类，不能使用final关键字声明。
	抽象类，是可以定义构造方法的，并且子类在实例化之前肯定要先对父类进行实例化。也可以通过super关键字明确指定调用的构造方法（传参）。
抽象方法：
	只声明而未实现的方法称为抽象方法，必须使用abstract关键字声明。
	
	抽象类必须被子继承，子类如果不是抽象类必须覆写抽象类中的全部抽象方法。
	

**接口：
	是一种特殊的类，里面全部是由全局常量（static final）和公共的抽象方法所组成；

	接口中的抽象方法可以不加abstract关键字，而抽象类中的抽象方法必须加；

	接口的使用必须有子类，子类必须覆写全部抽象方法，implements关键字实现，一个子类可以同时实现多个接口；
	 则子类如果不是抽象类的话，肯定要覆写接口中的全部抽象方法。
	
	实现：
		class 类名 implements 接口A,接口b{}
	
	**继承抽象类实现接口：
		一个子类可以同时继承抽象类和实现接口；
		格式如下：
			class 子类    extends 抽象类    implements 接口A,接口B...{s}
	
	接口不能继承抽象类，但是抽象类可以实现多个接口；
	
	一个接口可以同时继承多个接口，实现接口的多继承。
	
******************************
			多态性
java中的多态性主要体现在：
	1.方法的重载：发生在本类（根据传入的参数不同，完成的功能也不同）
	       方法的覆写：子类覆写父类中的方法；
	2.对象的多态性：
		1.向上转型：子类的实例化对象由父类接收；（自动完成）
			向上转型，程序会自动完成，格式：
				父类     父类对象     =  子类实例;
				
			向上转型，其实就是为了调用子类中覆写过的方法；
			
		2.向下转型：父类的实例化对象由子类接收；（需要强制）
				 在发生向下转型关系之前必须先发生向上的转型关系。
			向下转型，必须明确的指明要转型的子类类型，格式：
				子类     子类对象     = (子类)父类实例;

			向下转型，其实就是为了调用父类中没有被覆写过的方法；
			
			向下转型时，最好进行验证（使用instanceof），避免类转换异常。

	对象在向下转型时，一定要先进行向上转型。

***
	一个类永远不要去继承一个已经实现好的类，而只能继承抽象类或实现接口。
***


instanceof关键字：
	在java中可以使用instanceof关键字判断一个对象是否是某个类的实例。


*
**抽象类与接口的实现：
	在java中可以通过对象的多态性，为抽象类和接口实例化，这样在使用抽象类和接口的时候就可以调用本子类中所覆写过的方法了。
	
	接口实际上还表示将方法的视图暴露给远程的客户端。
	
  ***设计模式：
	
	**工厂设计模式：
		得到接口实例的过渡端，称为工厂。
	**代理设计模式：
		一个代理主题来操作真实主题，真实主题执行具体业务操作，而代理主题负责其他相关业务的代理。
	**适配器设计模式：
		在java的图形界面上用到非常多。
		例如：如果一个子类实现了一个接口，则肯定在子类中必须覆写此接口中的全部抽象方法，那么这样一来，如果一个接口中提供的抽象方法过多，而且，没有必要全部实现的话，肯定很浪费。
			就是用一个抽象类，实现接口中的所有方法，然后在用一个子类取继承抽象类后，根据需要实现需要使用的方法。
	**内部类扩展：
		在抽象类中可以定义内部接口；
		在接口中也可以定义内部抽象类；


****抽象类和接口的区别？
	抽象类：
		定义：包含一个抽象方法的类；
		组成：构造方法、抽象方法、普通方法、常量、变量
		使用：子类继承抽象类（extends）
		关系：抽象类可以实现多个接口；
		对象：都通过对象的多态性产生实例化对象；
		局限：抽象类有单继承的局限；
		实际：作为一个模板；
		选择：如果抽象类和接口都可以用的话，优先使用接口，因为避免单继承的局限；
		特殊：一个抽象类中可以包含多个接口，一个接口中可以包含多个抽象类；
		常见设计模式:模板设计；
	接口：	
		定义：抽象方法和全局常量的集合；
		组成：常量、抽象方法；
		使用：子类实现接口（implements）
		关系：接口不能继承抽象类，但允许继承多个接口；
		对象：通过对象的多态性产生实例化对象；
		局限：接口没有局限；
		实际：是作为一个标准或是表示一种能力
		选择：如果抽象类和接口都可以用的话，优先使用接口，因为避免单继承的局限；
		特殊：一个抽象类中可以包含多个接口，一个接口中可以包含多个抽象类；
		常见设计模式:工厂设计、代理设计；
		
	重要提示：
		一个类永远不要继承一个已经实现好的类，要么继承抽象类，要么实现接口，如果接口和抽象类同时都可以使用的话，那么优先使用接口，避免单继承的出现。
				
Object类：如果一个类没有明确继承的类，则默认继承object类。
	
	Object类中的主要方法：
		public Object();构造方法
		一个完整的类，应该覆写以下三个Object类分方法：
		public boolean equals(Object obj);对象比较时调用
		public int hashCode();取得Hash码
		public String toString();对象打印时调用
		
		String类也是Object类的子类。
		
	Object是所有类的父类，则所有类的对象都可以使用Object接收，但是Object不光可以接收对象，还可以接收任意的引用数据类型（接口、数组等）。


包装类：
	因为java的宗旨是：一切皆对象，而八种基本数据类型不是对象，所有需要将八种数据类型包装成对象。
		把int包装成一个类，这样就可以使用对象操作基本数据类型了。
		
			int		Integer
			char	Character
			short 	Short
			long	Long
			float	Float
			double	Double
			boolean	Boolean
			byte	Byte
			
		Integer Byte Float Double Short Long都属于Number类的子类，Number类本身提供了一系列的返回以上六种基本数据类型的操作。
			Number类是一个抽象类，主要是将数字包装类中内容变为基本数据类型。
				主要方法如下：
					public byte void Value();以byte形式返回指定的数值
					public abstract double doubleValue();以double形式返回指定的数值
					public abstract float floatValue();以float形式返回指定的数值
					public abstract int intValue();以int形式返回指定的数值
					public abstract long longValue();以long形式返回指定的数值
					public short shortValue();以short形式返回指定的数值
		
		Character属于Object的直接子类。
		
		Boolean属于Object的直接子类。
	
	装箱及拆箱：
		装箱：将基本数据类型变为包装类称为装箱；
		拆箱：将包装类的类型变为基本数据类型称为拆箱。
		
		自动装箱：
			Integer i = 30;
		自动拆箱：
			int x = i;
	
	包装类应用：
		将一个全由数字组成的字符串转变成int或者float类型的数据。
			A、Integer类（字符串转int型）
				public static int parseInt(String s)throws NumberFormatException
				
			B、Float类（字符串转float型）
				public static float parseFloat(String s)throws NumberFormatException		
	
		
匿名内部类：
	内部类：在一个类的内部还有另一个类称为内部类；
	匿名内部类：如果一个类在整个操作过程中，只使用一次的话，就可以将其定义为匿名内部类。
			匿名内部类是在接口及抽象类的基础上发展起来的。
		
异常（Exception）：	
	导致程序中断运行的一种指令流。
	try中捕获异常，出现异常之后的代码将不再被执行，而是跳转到相应的catch语句中执行，用于处理异常。
	对于异常可以设置其统一的出口，使用finally完成。		
	
	异常类的继承结构：
		最常用的类：Exception、Error，这两个类全都是Throwable的子类。
		Exception：一般表示的是程序中出现的问题，可以直接使用try...catch处理。
		Error：一般指的是JVM错误，程序中无法处理。	
		
		一般在输出异常信息的时候，可以直接使用System.out.println()打印异常对象。
		也可以通过Exception提供的一个方法，public void printStackTrace()方法。
	
	java的异常处理机制：
		1.一旦产生异常，则首先会产生一个异常类的实例化对象；
		2.在try语句中对此异常进行捕捉；
		3.产生的异常对象与catch语句中的各个异常类型进行匹配，如果匹配成功，则执行catch语句中的代码。	
		
	在异常处理中，捕获更粗的异常要放在捕获更细的异常之后。	
		
	throw和throws关键字：
		throws关键字：
			使用throws声明的方法表示此方法不处理异常，而交给方法的调用处进行处理。
			格式：
				public 返回值类型   方法名称(参数列表。。。)throws 异常类{}
		throw关键字：
			作用是在程序中抛出一个异常，抛出的是一个异常类的实例化对象；		
			格式：
				throw new Exception("coutent");
		
	***RuntimeException与Exception的区别？
		在java的异常处理机制中：
			1.如果抛出的是Exception的类型，则必须使用try...catch进行处理；
			2.如果抛出的是RuntimeException的类型，则不是必须使用try...catch处理，一旦发生异常之后将由JVM进行处理，但是为了保证程序的健康性，建议在有可能发生异常的地方还是老实的使用try...catch进行处理。	
	
	自定义异常类：
		只需要继承Exception就可以完成自定义异常类。因为在JAVA中提供的都是标准的异常类（包括一些异常信息等待），如果需要定义自己想要的异常信息的时候就可以自定义异常类。			
		
		
	断言：
		就是肯定某一个结果的返回值是正确的，如果最终此结果的返回值是错误的，则通过断言检查肯定会为用户提示错误信息。
		格式：
			assert Boolean表达式；
			assert boolean表达式：详细的信息	
		
包及访问控制权限：
	所谓的包实际上就是一个文件夹；
	打包命令：
		javac -d . 类名.java
		javac -d . *.java
	包的导入：
		import 报名称.子包名称.类名称;//手工导入
		import 报名称.子包名称.*;//JVM自动导入
	系统常见包：	
		java.lang
			此包为基础包，像String这样的类就保存在此包之中；
		java.lang.reflect
			此包为反射机制的包，是java.lang的子包；
		java.util
			此包为工具包，一些常用的类库、日期操作等都在此包之中；
		java.text
			提供了一些文本的处理类库；
		java.sql
			数据库操作包，提供了各种数据库操作的类和接口；
		java.net
			完成网络编程；
		java.io
			输入、输出处理
		java.awt
			包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面（GUI）；
		javax.swing
			此包用于建立图形用户界面，此包中的组件相对于java.awt而言是轻量级组件。	
			
	静态导入：
		如果一个类中的方法都是static的，则可以通过静态导入；
		格式：
			import static 包名.类名.*;

	jar命令：
		将所有的*.class文件压缩成一个文件交付给可以使用，这个文件就叫jar文件。
		如果想要生成jar文件，直接使用	jdk中bin目录里的jar.exe就可以将所有的类文件进行压缩。
		主要参数：
			“T”：查看jar包中的内容；
			“C”：创建新的文档；
			“V”：生成详细的输出信息；
			“F”：指定存档的文件名。
		打jar包命令：
			javac -d . 类名.java
			jar  -cvf  打成jar包后的名称.jar  要打包的文件夹或文件
			一个jar包如果想要使用的话，则必须配置classpath路径；
				set classpath = .; d:\xx\xx.jar	
					类文件所在的当前文件夹和jar包所在的目录			

	访问控制权限：
		private：不能被类的外部所看到；
		default：可以在本包中的任意地方访问；
		protected：包含，不同包的非子类不可以访问；
		public：公共的，都可以访问，不受任何的限制。

java命名规范：
	类：所有单词的首字母大写；
	方法：第一个单词的首字母小写，之后的每个单词的首字母大写；
	属性：第一个单词的首字母小写，之后的每个单词的首字母大写；
	包：所有单词的字母小写；
	常量：所有单词的字母大写。


回顾：
		当产生了一个类之后，为了保证类中的内容不被外部直接看到，则使用private关键字；
		但是，如果现在两个有关系的类要进行属性互相访问的话，之前只能使用getter/setter取得和设置，
	所以为了减少私有属性的访问的麻烦，使用了内部类，但是内部类本身会破坏程序的结构。
		为了让一个类的内容可以继续访问的时候，使用了继承的概念，但是在继承中private属性也是无法被子类
	看到的，所以此时，为了方便子类的操作，可以将属性使用protected进行封装，这样一来外部也无法直接看到（不同包）。	
		之后有了继承的概念，既然有了父子的关系，所有就可以使用向上或向下的转型操作，以完成多态性，但是在开发中类
	与类之间的直接继承并不多见，而往往是继承抽象类或实现接口，当若干个操作间需要解耦合的时候就可以使用接口完成。
		既然有内部类，则如果一个接口或抽象类的子类只使用一次，则可以将其定义为匿名内部类。
		开发中没有包的类是绝对不存在的。
		继承-->封装-->多态。	

多线程：
	1)java中的多线程实现：
		1.继承Thread类：
			Thread类是在java.lang包中定义的，一个类只要继承了Thread类，此类就称为多线程操作类。
			在Thread子类之中，必须明确的覆写Thread类中的run()方法，此方法为线程的主体：
			多线程定义语法：
				class 类名称    extends Thread{	//继承Thread类
					属性...;					//类中定义属性
					方法...;					//类中定义方法
					//覆写Thread类中的run()方法，此方法时线程的主体
					public void run(){
						线程主体...;
					}
				}
				
			native关键字：是一个由Java调用本机操作系统函数的一个关键字。
			
			一个线程对象只能启动一次。
			
		2.实现Runnable接口：
			在Java中也可以通过实现Runnable接口的方式实现多线程，Runnable接口中只定义了一个抽象方法；
				public void run();
			通过Runnable接口实现多线程：
				class 类名称    implements Runnable{		//实现Runnable接口
					属性...;				//类中定义属性
					方法...;				//类中定义方法
					public void run(){		//覆写Runnable接口里的run()方法
						线程主体;
					}
				}
				
			利用Thread类中的可以接收Runnable接口实例的构造方法，启动线程；
			
			因为接口可以避免单继承，所有使用Runnable接口方式；
			
			Thread类也是Runnable接口的子类；
				
		3.Thread类和Runnable接口的区别？
			使用Thread类在操作多线程的时候，无法达到资源共享的目的；而使用Runnable接口实现的多线程操作可以实现资源共享。

		4.实现Runnable接口比继承Thread类的优点：
			1.适合多个相同程序代码的线程去处理同一个资源；
			2.可以避免由于单继承局限所带来的影响；
			3.增强了程序的健壮性，代码能够被多个线程共享，代码与数据是独立的；
			结论：
				开发中使用实现Runnable接口是最合适的。
				
		5.线程的状态：
			创建状态：准备好了一个多线程的对象：Thread t = new Thread();
			
			就绪状态：调用了start()方法，等待CPU进行调度；
			
			运行状态：执行run()方法；
			
			阻塞状态：暂时停止执行，可能将资源交给其他线程使用；
		
			终止状态：(死亡状态)：线程执行完毕了，不再使用了。
			
			结论：
				实际上，线程在调用start()方法的时候不是立刻启动的，而是要等待CPU进行调度的。
		6.总结：
			1.进程和线程的区别，关系？
				线程是在进程的基础上划分的；
				线程消失了进程不会消失，进程如果消失了，则线程肯定消失。
			2.Java实现多线程的两种方式：
				继承Thread类
				实现Runnable接口
			3.线程的启动，通过start()方法完成，需要进行CPU调度，调用start()方法实际上调用的就是run()方法；
			4，Thread类也是Runnable接口的子类，使用了代理机制完成；
			5.在使用多线程的时候建议通过实现Runnable接口的方式实现，这样可以避免由于单继承所带来的开发局限，而且通过使用
			  Runnable接口也可以达到资源共享的目的。
	
	2)线程的常用操作方法：
		public Thread(Runnable target);
			构造方法；接收Runnable接口子类对象，实例化Thread对象；
		public Thread(Runnable target,String name);
			构造方法；接收Runnable接口子类对象，实例化Thread对象，并设置线程名称；
		public Thread(String name);
			构造方法；实例化thread对象，并设置线程名称；
		public static Thread currentThread();
			普通方法；返回目前正在执行的线程；
		public final String getName();
			普通方法；返回线程的名称；
		public final int getPriority();
			普通方法；发挥线程的优先级；
		public boolean isInterrupted();
			普通方法；判断目前线程是否被中断，如果是，返回true；否则返回false；
		public final boolean isAlive();
			普通方法；判断线程是否在活动，如果是，返回true；否则返回false；
		public final void join() throws InterruptedException
			等待线程死亡；
		public final synchronized void join(long millis)throws InterruptedException
			等待millis毫秒后，线程死亡；
		public void run();
			普通方法；执行线程；
		public final void setName(String name);
			普通方法；设定线程名称；
		public final void setPrioriy(int newPriority);
			普通方法；设定线程的优先值；
		public static void sleep(long millis)throws InterruptedException
			普通方法；使目前正在执行的线程休眠millis毫秒；
		public void start();
			普通方法；开始执行线程；
		public static void yield();
			普通方法；将目前正在执行的线程暂停，允许其它线程执行；
		public final void setDaemon(boolean on);
			普通方法；讲一个线程设置成后台运行；
		public final void setPriority(int newPriority);
			普通方法；更改线程的优先级；

	3)线程名称：
		在Thread类中，可以通过currentThread().getName()方法取得线程的名称，通过currentThread().setName()方法设置线程的名称；
		线程的名称一般在启动线程前设置，但也允许为已经运行的线程设置名称。允许两个Thread对象有相同的名字，但为了清晰，应该尽量避免这种情况的发生；
		另外，如果程序并没有为线程指定名称，则系统会自动的为线程分配一个名称。

		Java运行时，至少启动了两个线程：1.主线程；2.GC（垃圾回收线程）

	4)判断线程是否运行：
		同过isAlive()方法，判断线程是否执行完毕；
		
	5)线程的强制运行：
		使用join()方法让一个线程强制运行，线程强制运行期间，其他线程无法运行，必须等到此线程完成之后才可以继续执行。

	6)线程的休眠：
		使用sleep()方法停止线程运行；

	7)中断线程：
		当一个线程运行的时候，另外一个线程可以直接通过interrupt()方法，中断其运行状态；
		
	8)后台线程：
		使用setDaemon()方法可以实现设置一个后台线程。

	9)线程的优先级：
		在Java的线程操作中，所有的线程在运行前都会保持在就绪状态，那么此时，哪个线程的优先级高，哪个线程就有可能会先被执行；

	10)线程的礼让：
		在线程操作中，也可以使用yield()方法将一个线程的操作暂时让给其他线程执行。



要求：
	设计一个线程操作类，要求可以产生三个线程对象，并可以分别设置三个线程的休眠时间，如下所示：
		1.线程A,休眠10秒
		2.线程B,休眠20秒
		3.线程C,休眠30秒
	问：此类该如何设计？
	






















































































































































	