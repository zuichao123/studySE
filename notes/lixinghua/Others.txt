this:代表当前对象
	如果一个类中有多个构造方法时，可以使用this关键字调用。
	在使用this关键字调用其他构造方法时：
		1.this()只能放在代码的首行；
		2.至少有一个构造方法是不用this()调用的，否则会出现构造方法递归调用。
		
static关键字：声明全局属性。
	最好实用类名调用。
	实用static不能调用非static的方法和属性。
		因为：static可以在对象没有实例化时就可以调用，而非static属性和方法，在实例化后才能被调用。

java中到底有多少个内存区域呢？
	1.栈内存：可以保持对象的名称（保存，访问的堆内存的地址）
	2.堆内存：保存每个对象的具体属性
	3.全局数据区：保存static类型的属性
	4.全局代码区：保存所有方法的定义

代码块：
	普通代码块；
		定义在方法中
	构造块；
		定义在类中；
		构造块优先于构造方法执行，且执行多次，只要一有实例化对象产生，就执行构造块中的内容。
	静态代码块：
		在主方法中定义的代码块；
		优先于主方法执行。只执行一次。
		
	静态块优先于主方法执行，如果在普通类中定义的静态块，优先于构造块执行，不管有多少个实例化对象产生，静态代码块只执行一次，静态代码块的主要功能就是为静态属性初始化。
	
构造方法私有化：单例模式：核心，就是将类的构造方法私有化，之后在类的内部产生实例化对象，并通过类的静态方法返回实例化对象的引用。
	的好处？
		1.对象唯一
		
对象数组：就是指包含了一组相关的对象，里面的每一个对象都是null值，使用时必须分别进行实例化操作。
	格式：类   对象数组名称[] = new 类[数组长度]
		Aa aa[] = new Aa[10];
		
内部类：编译后生成：外部类$内部类名称.class
	缺点：正常的一个类操作时，在类中最好只定义属性或方法。如果定义一个类的话，则肯定破坏了程序的一个结构。
	优点：可以方便的访问外部类中的私有属性。	
	
	使用static关键字定义内部类后，可以使用外部类名称.内部类名称来调用。
	
	一个内部类除了可以通过外部类访问，也可以直接在其他类中调用，格式：
		外部类.内部类   内部类对象 = 外部类实例.new 内部类();
		
	方法中定义内部类：如果该内部类要访问此方法的变量时，此变量必须定义为final。

链表：	
	增加节点是在链表的最后进行增加；
	查找节点就是依次递归的方式查找；
	删除节点，实际上就是改变引用传递的地址。
	
继承：extends子类继承父类，扩展功能。
	通过super关键字，可以从子类访问父类中的内容。

	方法的重载与覆写的区别：
		重载：方法名相同，参数的类型或个数不同；对权限没有要求；发生在一个类中。
		覆写：方法名称、参数的类型、返回值类型全部相同；被覆写的方法不能拥有更严格的权限；反生在继承类中。
	
	不管任何时候，子类实例化对象时，默认先去调用父类中的无参构造方法，再调用子类的构方法。

this与super关键字的区别：
	this：
		属性访问：访问本类中的属性，如果本类没有此属性则从父类中继续查找；
		方法：访问本类中的方法，如果本类中没有此方法，则从父类中继续查找；
		调用构造：调用本类构造，必须放在构造方法的首行；
		特殊：表示当前对象。
	super：
		属性访问：访问父类中的属性；
		方法：直接访问父类中的方法；
		调用构造：调用父类构造，必须放在子类构造方法的首行；
		特殊：无此概念。
	this和super都可以调用构造方法，而且必须放在构造方法的首行，所以这两个关键字不能同时使用。

final关键字：
	可以使用final关键字声明类、属性、方法：
		使用final关键字声明的类不能有子类；
		使用final关键字声明的方法不能被子类所覆写；
		使用final关键字声明的变量即成为常量，常量不可以修改。
		
抽象类：
	包含一个抽象方法的类就称为抽象类；
抽象方法：
	只声明而未实现的方法称为抽象方法，必须使用abstract关键字声明。
	
	抽象类必须被子继承，子类如果不是抽象类必须覆写抽象类中的全部抽象方法。
	

































































	