				封装性
this:代表当前对象
	如果一个类中有多个构造方法时，可以使用this关键字调用。
	在使用this关键字调用其他构造方法时：
		1.this()只能放在代码的首行；
		2.至少有一个构造方法是不用this()调用的，否则会出现构造方法递归调用。
		
static关键字：声明全局属性。
	最好实用类名调用。
	实用static不能调用非static的方法和属性。
		因为：static可以在对象没有实例化时就可以调用，而非static属性和方法，在实例化后才能被调用。

java中到底有多少个内存区域呢？
	1.栈内存：可以保持对象的名称（保存，访问的堆内存的地址）
	2.堆内存：保存每个对象的具体属性
	3.全局数据区：保存static类型的属性
	4.全局代码区：保存所有方法的定义

代码块：
	普通代码块；
		定义在方法中
	构造块；
		定义在类中；
		构造块优先于构造方法执行，且执行多次，只要一有实例化对象产生，就执行构造块中的内容。
	静态代码块：
		在主方法中定义的代码块；
		优先于主方法执行。只执行一次。
		
	静态块优先于主方法执行，如果在普通类中定义的静态块，优先于构造块执行，不管有多少个实例化对象产生，静态代码块只执行一次，静态代码块的主要功能就是为静态属性初始化。
	
构造方法私有化：单例模式：核心，就是将类的构造方法私有化，之后在类的内部产生实例化对象，并通过类的静态方法返回实例化对象的引用。
	的好处？
		1.对象唯一
		
对象数组：就是指包含了一组相关的对象，里面的每一个对象都是null值，使用时必须分别进行实例化操作。
	格式：类   对象数组名称[] = new 类[数组长度]
		Aa aa[] = new Aa[10];
		
内部类：编译后生成：外部类$内部类名称.class
	缺点：正常的一个类操作时，在类中最好只定义属性或方法。如果定义一个类的话，则肯定破坏了程序的一个结构。
	优点：可以方便的访问外部类中的私有属性。	
	
	使用static关键字定义内部类后，可以使用外部类名称.内部类名称来调用。
	
	一个内部类除了可以通过外部类访问，也可以直接在其他类中调用，格式：
		外部类.内部类   内部类对象 = 外部类实例.new 内部类();
		
	方法中定义内部类：如果该内部类要访问此方法的变量时，此变量必须定义为final。

链表：	
	增加节点是在链表的最后进行增加；
	查找节点就是依次递归的方式查找；
	删除节点，实际上就是改变引用传递的地址。
	
**********************************
			继承性	

继承：extends子类继承父类，扩展功能。
	通过super关键字，可以从子类访问父类中的内容。

	方法的重载与覆写的区别：
		重载：方法名相同，参数的类型或个数不同；对权限没有要求；发生在一个类中。
		覆写：方法名称、参数的类型、返回值类型全部相同；被覆写的方法不能拥有更严格的权限；反生在继承类中。
	
	不管任何时候，子类实例化对象时，默认先去调用父类中的无参构造方法，再调用子类的构方法。

this与super关键字的区别：
	this：
		属性访问：访问本类中的属性，如果本类没有此属性则从父类中继续查找；
		方法：访问本类中的方法，如果本类中没有此方法，则从父类中继续查找；
		调用构造：调用本类构造，必须放在构造方法的首行；
		特殊：表示当前对象。
	super：
		属性访问：访问父类中的属性；
		方法：直接访问父类中的方法；
		调用构造：调用父类构造，必须放在子类构造方法的首行；
		特殊：无此概念。
	this和super都可以调用构造方法，而且必须放在构造方法的首行，所以这两个关键字不能同时使用。

final关键字：
	可以使用final关键字声明类、属性、方法：
		使用final关键字声明的类不能有子类；
		使用final关键字声明的方法不能被子类所覆写；
		使用final关键字声明的变量即成为常量，常量不可以修改。
		
抽象类：
	包含一个抽象方法的类就称为抽象类；
	抽象类，不能被实例化；
	抽象类，必须有子类；子类必须覆写抽象类中的全部抽象方法。
	抽象类，不能使用final关键字声明。
	抽象类，是可以定义构造方法的，并且子类在实例化之前肯定要先对父类进行实例化。也可以通过super关键字明确指定调用的构造方法（传参）。
抽象方法：
	只声明而未实现的方法称为抽象方法，必须使用abstract关键字声明。
	
	抽象类必须被子继承，子类如果不是抽象类必须覆写抽象类中的全部抽象方法。
	

**接口：
	是一种特殊的类，里面全部是由全局常量（static final）和公共的抽象方法所组成；

	接口中的抽象方法可以不加abstract关键字，而抽象类中的抽象方法必须加；

	接口的使用必须有子类，子类必须覆写全部抽象方法，implements关键字实现，一个子类可以同时实现多个接口；
	 则子类如果不是抽象类的话，肯定要覆写接口中的全部抽象方法。
	
	实现：
		class 类名 implements 接口A,接口b{}
	
	**继承抽象类实现接口：
		一个子类可以同时继承抽象类和实现接口；
		格式如下：
			class 子类    extends 抽象类    implements 接口A,接口B...{s}
	
	接口不能继承抽象类，但是抽象类可以实现多个接口；
	
	一个接口可以同时继承多个接口，实现接口的多继承。
	
******************************
			多态性
java中的多态性主要体现在：
	1.方法的重载：发生在本类（根据传入的参数不同，完成的功能也不同）
	       方法的覆写：子类覆写父类中的方法；
	2.对象的多态性：
		1.向上转型：子类的实例化对象由父类接收；（自动完成）
			向上转型，程序会自动完成，格式：
				父类     父类对象     =  子类实例;
				
			向上转型，其实就是为了调用子类中覆写过的方法；
			
		2.向下转型：父类的实例化对象由子类接收；（需要强制）
				 在发生向下转型关系之前必须先发生向上的转型关系。
			向下转型，必须明确的指明要转型的子类类型，格式：
				子类     子类对象     = (子类)父类实例;

			向下转型，其实就是为了调用父类中没有被覆写过的方法；
			
			向下转型时，最好进行验证（使用instanceof），避免类转换异常。

***
	一个类永远不要去继承一个已经实现好的类，而只能继承抽象类或实现接口。
***


instanceof关键字：
	在java中可以使用instanceof关键字判断一个对象是否是某个类的实例。


*
**抽象类与接口的实现：
	在java中可以通过对象的多态性，为抽象类和接口实例化，这样在使用抽象类和接口的时候就可以调用本子类中所覆写过的方法了。
	
	接口实际上还表示将方法的视图暴露给远程的客户端。
	
  ***设计模式：
	
	**工厂设计模式：
		得到接口实例的过渡端，称为工厂。
	**代理设计模式：
		一个代理主题来操作真实主题，真实主题执行具体业务操作，而代理主题负责其他相关业务的代理。
	**适配器设计模式：
		在java的图形界面上用到非常多。
		例如：如果一个子类实现了一个接口，则肯定在子类中必须覆写此接口中的全部抽象方法，那么这样一来，如果一个接口中提供的抽象方法过多，而且，没有必要全部实现的话，肯定很浪费。
			就是用一个抽象类，实现接口中的所有方法，然后在用一个子类取继承抽象类后，根据需要实现需要使用的方法。
	**内部类扩展：
		在抽象类中可以定义内部接口；
		在接口中也可以定义内部抽象类；


****抽象类和接口的区别？
	抽象类：
		定义：包含一个抽象方法的类；
		组成：构造方法、抽象方法、普通方法、常量、变量
		使用：子类继承抽象类（extends）
		关系：抽象类可以实现多个接口；
		对象：都通过对象的多态性产生实例化对象；
		局限：抽象类有单继承的局限；
		实际：作为一个模板；
		选择：如果抽象类和接口都可以用的话，优先使用接口，因为避免单继承的局限；
		特殊：一个抽象类中可以包含多个接口，一个接口中可以包含多个抽象类；
		常见设计模式:模板设计；
	接口：	
		定义：抽象方法和全局常量的集合；
		组成：常量、抽象方法；
		使用：子类实现接口（implements）
		关系：接口不能继承抽象类，但允许继承多个接口；
		对象：通过对象的多态性产生实例化对象；
		局限：接口没有局限；
		实际：是作为一个标准或是表示一种能力
		选择：如果抽象类和接口都可以用的话，优先使用接口，因为避免单继承的局限；
		特殊：一个抽象类中可以包含多个接口，一个接口中可以包含多个抽象类；
		常见设计模式:工厂设计、代理设计；
		
	重要提示：
		一个类永远不要继承一个已经实现好的类，要么继承抽象类，要么实现接口，如果接口和抽象类同时都可以使用的话，那么优先使用接口，避免单继承的出现。
				
	




















































	