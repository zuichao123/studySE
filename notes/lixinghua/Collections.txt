java类集：
	类集实际上就是一个动态的对象数组，与一般的对象数组不同，类集中的对象内容可以任意扩充。
	类集的特征：
		1.这种框架是高性能的；
		2.框架必须允许不同类型的类集以相同的方式和高度互操作方式工作；
		3.类集必须是容易扩展和修改的。
	对象数组中包含一组对象，但是对象数组使用的时候存在一个长度的限制，那么类集是专门解决这种限制的，使用类集可以方便的向数组中增加任意多个数据。
	类集框架主要接口：
		Collection：存放对象
			是存放一组单值的最大接口，所谓的单值是指集合中的每个元素都是一个对象。一般很少会直接使用此接口直接操作；
		List：可重复
			是Collection接口的子接口，也是最常用的接口，此接口对Collection接口进行了大量的扩充，里面的内容是允许重复的；
		Set：不可重复
			是Collection接口的子接口，没有对Collection接口进行扩充，里面不允许存放重复内容；	
		Map：成对存放
			Map是存放一对值的最大接口，即，接口中的每一个元素都是一对，以key->value的形式保存。
		Iterator：
			集合的输出接口，用于输出集合中的内容，只能进行从前到后的单向输出；
		ListIterator：
			是Iterator的子接口，可以进行双向输出；
		Enumeration：
			是最早的输出接口，用于输出指定集合中的内容；
		SortedSet：
			单值的排序接口，实现此接口的集合类，里面的内容是可以排序的，使用比较器排序；
		SortedMap：
			存放一对值的排序接口，实现此接口的集合类，里面的内容按钮key排序，使用比较器排序；
		Queue：
			队列接口，此接口的子类可以实现对象操作；
		Map.Entry：
			Map.Entry的内部接口，每个Map.Entry对象都保存着一对key->value的内容，每个Map接口中都保存多个Map.Entry接口实例。
	
	以上接口必须全部掌握。
	
	1.Collection接口：java.util包中
		是保存单值集合的最大父接口；
		定义格式：		 
			public interface Collection<E> extends Iterable<E>
		常用方法：
			public boolean add(E o)
				向集合中插入对象；
			public boolean addAll(Collection<? extends E> c)
				将一个集合的内容插入进来；
			public void clear()
				清除此集合中所有元素；
			public boolean contains(Object o)
				判断某一个对象是否在集合中存在；
			public boolean containsAll(Collection<?> c)
				判断一组对象是否在集合中存在；
			public boolean equals(Object o)
				对象比较；
			public int hashCode()
				哈希码；
			public boolean isEmpty()
				判断集合是否为空；
			public Iterator<E> iterator()
				为Iterator接口实例化；
			public boolean remove(Object o)
				删除指定对象；
			public boolean removeAll(Collection<?> c)
				删除一组对象；
			public boolean retainAll(Collection<?> c)
				保存指定内容；
			public int size()
				求出集合的大小；
			public Object[] toArray()
				将一个集合变为对象数组；
			public <T> T[] toArray(T[] a) 
				指定好返回的对象数组类型；
		
		*Collection接口的使用注意：
			在一般开发中，往往很少直接使用Collection接口进行开发，因为表示的操作意义不明确。
			而基本上都是使用其子接口，主要有：List、Set、Queue、SortedSet。
				List接口：可以存放重复的内容；
				Set接口：不能存放重复的内容，所有的重复内容是靠hashCode()和equals()两个方法区分的；
				Queue接口：队列接口；
				SortedSet接口：可以对集合中的数据进行排序；
		
		1.1 List接口：可重复
			本章目标：
				1.掌握List接口与Collection接口的关系；
				2.掌握List接口的常用子类：ArrayList、Vector；
				3.掌握ArrayList与Vector类的区别；
			
			List接口是Collection接口的子接口，List接口中可以存放任意的数据。而且在List接口中内容是允许重复的。
			定义格式：
				public interface List<E> extends Collection<E>	
			常用（扩展）方法：
				public void add(int index, E element)
					在指定位置增加元素；
				public boolaen addAll(int index, Collection<? extends E> c)
					在指定位置增加一组元素；
				E get(int index)
					返回指定位置的元素；
				public int indexOf(Object o)
					查找指定元素的位置；
				public int lastIndexOf(Object o)
					从后向前查找指定元素的位置；
				public ListIterator<E> listIterator()
					为ListIterator接口实例化；
				public E remove(int index)
					按指定的位置删除元素；
				public List<E> subList(int fromIndex, int toIndex)
					取出集合中的子集合；截取部分集合：
				public E set(int index, E element)
					替换指定位置的元素；
			
			1.1.1 List接口的常用子类--ArrayList：是List接口中最常用的子类；
				ArrayList是List接口的子类，可以直接通过对象的多态性，为List接口实例化；
				此类的定义格式如下：
					public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, Serializable
					
				AbstractList类的定义如下：
					public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E>
					
			1.1.2 Vector类：是List接口的子类：
				考虑到大多数人已经习惯了Vector类，Java设计者就让Vector类实现了已List接口，这才将其保存下来。但是因为其实List接口的子类，所有Vector类的使用与之前的并没有太大的区别；
				Vector类的定义如下：
					public class Vector<E> extends AbstractList<E> implements List<E> RandomAccess, Cloneable, Serializable
					
			***子类的差异：ArrayList与Vector的区别：
				1.推出时间：
					ArrayList：JDK1.2之后推出的，属于新的操作类；
					Vector：JDK1.0时推出的，属于旧的操作类；
				2.性能：
					ArrayList：采用异步处理的方式；
					Vector：采用同步的方式，性能较低；
				3.线程安全：
					ArrayList：属于非线程安全的操作类；
					Vector：属于线程安全的操作类；
				4.输出：
					ArrayList：只能使用Iterator、foreach输出；
					Vector：可以使用Iterator、foreach、Enumeration输出；
			
		1.2 Queue接口与LinkedList子类：
			队列操作（对头永远是新增的内容，队尾永远是先出的内容）
			1.2.1 LinkedList表示的是一个链表的操作类，此类的定义如下：
	 				public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Queue<E>, Clineable, Serializable
	 			LinkedList子类的常用方法：
					public void addFirst(E o)
						在链表开头增加元素；
					public vlid addLast(E o)
						在链表结尾增加元素；
					public boolean offer(E o)
						将指定元素增加到链表的结尾；
					public E removeFirst()
						删除链表的第一个元素；
					public E removeLast()
						删除链表的最后一个元素；
	 			LinkedList本身大量扩充了Queue接口和List接口的操作，所有在使用时最好直接使用LinkedList类完成操作。
	 		1.2.2 Queue接口是Collection的子接口，此接口定义如下：
	 				public interface Queue<E> extends Collection<E>	
				Queue接口的常用方法：
					public E element()
						找到链表的表头；
					public boolean offer(E o)
						将指定元素增加到链表的结尾；
					public E peek()
						找到但并不删除链表的头；
					public E poll()
						找到并删除链表的头；
					public E remove()
						检索并移除表头；
			
		1.3 Set接口：不可重复
			掌握：
				treeSet的排序原理；
				Set接口中重复元素的定义；
		
			Set接口也是Collection接口的子接口，但是与Collection或List接口不同的是，Set接口中不能加入重复的元素；
			Set接口的定义：
				public interface Set<E> extends Collection<E>
			Set接口的主要方法与Collection是一致的；
			Set接口的实例无法像List接口那样进行双向输出；因为没有提供get()方法；
			Set接口的常用子类：
				散列存放：HashSet
				有序存放：TreeSet
			
			 如果想要取消掉重复元素，则需要Object类中的两个方法帮助：
			 	*1.hashCode()：表示一个唯一的编码，一般通过计算表示；
			 	*2.equals()：进行对象的比较操作；
			 	
			 小结：
			 	Set接口依靠hashCode()和equals()完成重复元素的判断，关于这一点在日后的Map接口中也有体现；
			 	TreeSet依靠Compatable接口完成排序操作。
			
		1.4 SortedSet接口：排序接口
			TreeSet实际上也是SortedSet接口的子类：所以此接口的所有类都是可以排序的。
			SortedSet接口的定义如下：
				public interface SortedSet<E> extends Set<E>
			SortedSet接口中定义的方法：
				public Comparator<? super E> comparator()
					返回与排序有关联的比较器；
				public E first()
					返回集合中的第一个元素；
				public SortedSet<E> headSet(E toElement)
					返回从开始到指定元素的集合；
				public E last()
					返回最后一个元素；
				public SortedSet<E> subSet(E fromElement,E toElement)
					返回指定对象间的元素；
				public SortedSet<E> tailSet(E fromElement)
					从指定元素到最后；
					
			只要看到了SortedSet开头的接口，就是可以排序的接口。（按照Comparable排序）
			
		*1.5 Iterator接口：集合输出接口（从前向后输出，属于单向的输出）
			在集合的输出操作中，支持以下几种方式：
				1.Iterator
				2.ListIterator
				3.foreach
				4.Enumeration
			Iter接口简介：
				1.集合输出的标准操作：
					在使用集合输出的时候必须形成以下的一个思路：只要是碰到了集合输出的操作，就一定使用Iterator接口，因为这是最标准的做法；
				2.Iterator接口的操作原理：
					Iterator是专门的迭代输出接口，所谓的迭代输出就是将元素一个个进行判断，判断其是否有内容，如果有内容则把内容取出。
			
			对于Iterator而言，因为其本身是一个接口，所有要想实例化则必须依靠Collection接口完成。
			常用方法：
				public boolean hasNext()
					正向判断是否有内容；
				public E next()
					取出内容；
				public void remove()
					删除当前元素；
			
			如果在迭代输出过程中使用了List中的remove()执行删除操作，则代码将出现问题。
			在使用iterator输出时，不要使用集合类中的remove方法，而只能使用Iterator的remove方法。
			iterator接口的功能时从前向后输出，属于单向的输出；
			在使用iterator时，最后不要删除数据。
		
		1.6 ListIterator接口：集合输出接口（是Iterator的子接口，双向输出）
			是Iterator接口的子接口，主要功能实现了右前向后、右后向前的双向输出；
			ListIterator接口的定义如下：
				public interface ListIterator<E> extends Iterator<E>
			此接口可以进行双向输出操作，但是在Collection接口中并没有定义可以为此类实例化的操作，只有List接口中才存在了ListIterator接口的实例化操作（通过调用ListIterator()方法实现）。
			常用方法：
				public void add(E e)
					添加操作，将指定元素插入列表；
				public boolean hasPrevious()
					逆向判断是否有内容；
				public E previous()
					返回列表中的前一个元素
				public void set(E e)
					用指定元素替换next或previous返回的最后一个元素；
			
			注意：此操作时，必须先进行由前向后，再进行右后向前的操作。
		                            如果要想使用ListIterator接口，则只能依靠List接口完成；
			
		1.7 foreach及Enumeration接口：
			foreach输出：
				List<String> allList = new ArrayList<String>();
			
				allList.add("hello");
				allList.add("_");
				allList.add("world");
				
				for(String str : allList){
					System.out.print(str+"、");
				}
			
			Enumeration接口：
				在Java刚出来的时候，使用Enumeration接口完成输出；
				在使用Enumeration输出的时候一般都是直接操作Vector类完成的。
				常用方法：
					public boolean hasMoreElements()
						判断是否有内容；
					public E nextElement()
						输出内容
			注意：在所有的输出操作红，以Iterator接口为最标准的输出操作；
		
	*2.Map接口：	
		本章目标：
			1.掌握Map接口与Collection接口的不同；
			2.掌握Map接口与Map.Entry接口的关系；
			3.掌握Map接口的常用子类：HashMap、Hashtable、TreeMap、WeakHashMap；
			4.掌握HashMap与Hastable的区别。
		之前所讲解的Collection、Set、List接口都属于单值的操作，即每一次只能操作一个对象，而Map与他们不同的是，每次操作的是一对对象，即二元偶对象；
		Map中保存的是一对对象，对象的形式以：key-->value的形式保存的。此接口的定义如下：
			public interface Map<K,V>
		常用方法：
			public void clear()
				清空Map集合；
			public boolean containsKey(Object key)
				判断指定的key是否存在；
			public boolean containsValue(Object value)
				判断指定的value是否存在；
			public Set<Map.Entry<K,V>> entrySet()
				将Map对象变为Set集合；
			public boolean equals(Object o)
				对象比较；
			public V get(Object key)
				根据key取得value；
			public int hashCode()
				返回哈希码；
			public boolean isEmpty()
				判断集合是否为空；
			public Set<K> keySet()
				取得所有的key；
			public V put(K key, V value)
				向集合中加入元素；
			public void putAll(Map<? extends K, ? extends V> t)
				将一个Map集合中的内容加入到另一个Map；
			public V remove(Object key)
				根据key删除value；
			public int size()
				取出集合的长度；
			public Collection<V> values()
				取出全部的value；
		
		Map接口的常用子类：
			1.HashMap：无序存放的，是新的操作类，key不允许重复；
			2.Hashtable：无效存放的，是旧的操作类，key不允许重复；
			3.TreeMap：可以排序的Map集合，按集合中的key排序，key不允许重复。
			4.WeakHashMap：弱引用的Map集合，当集合中的某些内容不再使用时，可以清除掉无用的数据，可以使用gc进行回收；
			5.IdentityHashMap：key可以重复的Map集合；
			
		HashMap与Hashtable的区别：
			1.推出时间：
				HashMap：JDK1.2之后推出的，属于新的操作类；
				Hashtable：JDK1.0时推出的，属于旧的操作类；
			2.性能：
				HashMap：采用异步处理方式，性能更高；
				Hashtable：采用同步处理方式，性能较低；
			3.线程安全：
				HashMap：属于非线程安全操作类；
				Hashtable：属于线程安全的操作类；
			
		如果自定义的类要想作为key的话，则肯定要实现Comparable接口，指定比较规则。	
			
		对象引用的强度说明：
			从JDK1.2版本开始，Java把对象的引用分为四种级别，从而使程序能更加灵活的控制对象的声明周期。这四种级别又高到底依次是：
			强引用、软引用、弱引用、虚引用，这四种引用的区别如下：
				强引用：当内存不足时，jvm宁可出现OutOfMemeryError错误而使程序停止，也不会回收此对象来释放空间；
				软引用：当内存不足时，会回收这些对象的内存，用来实现内存敏感的高速缓存；
				弱引用：无论内存是否紧张，被垃圾回收器发现立即回收；
				虚引用：和没有任何引用一样。	
		
		2.1 Map.Entry接口：
			Map.Entry是Map中内部定义的一个接口，专门用来保存key―>value的内容。
			Map.Entry接口的定义格式：
				public static interface Map.Entry<K, V>
			Map.Entry接口的常用方法：
				public boolean equals(Object o)
					对象比较；
				public K getKey()
					取得key；
				public V getValue()
					取得value；
				public int hashCode()
					返回哈希码；
				public V setValue(V value)
					设置value的值；
		
		**小结：
			Map是Java中的接口，Map.Entry时Map的一个内部接口，java.util.Map.Entry接口主要就是在遍历Map的时候用到；
			Map提供了一些常用方法：
				keySet():返回的是Map中key值的集合；
				entrySet():返回的是类型为Map.Entry的Set集合；
			Map.Entry接口为泛型，表示Map中的一个实体（一个key-value对），接口中有getKey()方法和getValue()方法。
			Map的主要功能就是查找，根据key找到value。
		
		2.2 Map接口使用的注意事项：
			1.掌握Map接口的输出操作；
			2.掌握Map接口中key类的定义标准；
			
			对应Map接口来说，其本身是不能直接使用迭代（例如：Iterator、foreach）进行输出的，因为Map中的每一个位置存放的是一对值（key―value），而Iterator中每次只能找到一个值。
			如果非要使用迭代输出的话，则必须按照以下步骤完成（以Iterator输出方法为例：）：
				1.将Map的实例通过entrySet()方法变为Set接口对象；
				2.通过Set接口实例为Iterator实例化；
				3.通过Iterator迭代输出，每个内容都是Map.Entry的对象；
				4.通过Map.Entry进行key-value的分离。
		
			注意：直接使用非系统类作为key；
				如果要使用非系统类作为Map的key，则此类必须覆写Object类中的以下两个方法：
					1.hashCode()
					2.equals()
			
		2.3 IdentityHashMap类：
			在正常的map操作中，key本身是不能重复的；
			如果现在要求key的值可以重复，就要使用IdentityHashMap类；
			
		2.4 SortedMap类：
			集合排序：是TreeMap集合的父类；
			常用扩展方法：
				public Comparator<? super K> comparator()
					返回比较器对象；
				public K firstKey()
					返回第一个元素key；
				public SortedMap<K, V> headMap(K toKey)
					返回小于等于指定key的部分集合；
				public K lastKey()
					返回最后一个元素的key；
				public SortedMap<K, V> subMap(K fromKey, K toKey)
					返回指定key范围的集合；
				public SortedMap<K, V> tailMap(K fromKey)
					返回大于指定key的部分集合；
		
	3.集合工具类：Collections
		Collections与Collection没有直接关系，但是与集合中的各个接口都有操作的方法支持。
		在集合的应用开发中，集合的若干接口和若干子类时最最常使用的，但是在jdk中提供了一种集合操作的工具类--Collections，可以直接通过此类方便的操作集合。
		Collections类的定义如下：
			public class Collections extends Object
		
		Collections类的常用方法及常量：
			public static final List EMPTY_LIST
				返回一个空的List集合；
			public static final Set EMPTY_SET
				返回空的Set集合；
			public static final Map EMPTY_MAP
				返回空的Map集合；
			public static <T> boolean addAll(Collection<? super T> c, T...a)
				为集合添加内容；
			public static <T extends Object & Comparable<? super T>> T max(Collection<? extends T> coll)
				找到集合中最大的内容，按比较器排序；
			public static <T extends Object & Comparable<? super T>> T min(Collection<? extends T> coll)
				找到集合中最小的内容，按比较器排序；
			public static <T> boolean replaceAll(List<T> list, T oldVal, T newVal)
				用新的内容替换集合中的指定内容；
			public static void reverse(List<?> list)
				集合反转；
			public static <T> int binarySearch(List<? extends Comparable<? super T>> list, T key)
				查找集合中的指定内容；
			public static final <T> List<T> emptyList()
				返回一个空的List集合；
			public static final <K,V> Map<K,V> emptyMap()
				返回一个空的Map集合；
			public static final <T> Set<T> emptySet()
				返回一个空的Set集合；
			public static <T extends Comparable<? super T>> void sort(List<T> list)
				集合排序操作，根据Comparable接口进行排序；
			public static void swap(List<?> list,int i,int j)
				交换指定位置的元素；
	
	4.Stack类：
		栈是采用先进后出的数据存储方式，每一个栈都包含一个栈顶，每次出栈是将栈顶的数据取出；
		在java中使用Stack类进行栈的操作，Stack类是Vector的子类；
		Stack类的定义如下：
			public class Stack<E> extends Vector<E>
		常用方法：
			public boolean empty()
				测试栈是否为空；
			public E peek()
				查看栈顶，但不删除；
			public E pop()
				出栈，同时删除；
			public E push(E item)
				入栈；
			public int search(Object o)
				在栈中查找；	
	
	5.属性类Properties：
		Properties是Hashtable的子类，则也是Map的子类，可以使用Map的全部操作，但是在一般情况下属性类是单独使用的；	
		常用方法：
			public Object setProperty(String key, String value)
				设置属性；
			public String getProperty(String key)
				得到属性；
			public String getProperty(String key,String defaultValue)
				得到默认值，同时设置默认值；	
			public void store(OutputStream out,String comments)throws IOException
				将属性写入普通文件；
			public void load(InputStream inStream)throws IOException
				读取普通文件中的属性信息；
			public void storeToXML(OutputStream out,String comments)throws IOException
				将属性写入xml文件；
			public void loadFromXML(InputStream inStream)throws IOException
				读取xml文件中的属性信息；
		小结：	
			通过后续学习的java反射机制部分，了解属性类的应用；
			属性中的类型都是字符串，因为方便操作；
		
枚举：	enumeration	
	所谓的枚举就是规定好了指定的取值范围，所有的内容只能从指定的范围中取得。
	在JDK1.5之后，引入了一个新的关键字类型--enum，可以直接定义枚举格式，格式如下：
		[public] enum 枚举类型名称{
			枚举对象1,枚举对象2,枚举对象3,....,枚举对象n;
		}
	因为枚举已经指定好了范围，所有可以使用foreach进行全部的输出，使用“枚举.values()”的形式取得全部的枚举内容。	
	小结；
		使用枚举，可以限定取值的范围；
		使用enum关键字可以定义枚举；
	
	1.Enum类：
		使用enum可以定义一个枚举，实际上此关键字表示的是java.lang.Enum类型，即:使用enum声明的枚举类型，就相当于定义一个类，而此类则默认继承java.lang.Enum类。
		java.lang.Enum类的定义如下：
			public abstract class Enum<E extends Enum<E>> extends Object implements Comparable<E>, java.io.Serializable
		此种类型是可以比较、排序、可以序列化的。	
		枚举类的主要操作方法：
			protected Enum(String name,int ordinal)
				构造，接收枚举的名称和枚举的常量创建枚举对象；（一个表示枚举的名字，一个表示枚举的序号）
			protected final Object clone()throws CloneNotSupportedException
				克隆枚举对象；
			public final int compareTo(E o)
				对象比较；
			public final boolean equals(Object other)
				比较两个枚举对象；
			public final int hashCode()
				返回枚举常量的哈希码；
			public final String name()
				返回此枚举常量的序数；
			public static <T extends Enum<T>> T valueOf(Class<T> enumType,String name)
				返回带指定名称的指定枚举类型的枚举常量；
		一旦定义有参构造之后，在声明枚举对象的时候就必须明确的调用构造方法，并传递参数。
		
	2.类集对Enum的支持：
		2.1掌握EnumMap类的使用；
			Map接口的子类；
			定义如下：
				public class EnumMap<K extends Enum<K>,V> extends AbstractMap<K,V> implements Serializable, Cloneable
				
		2.2掌握EnumSet类的使用；
			Set接口的子类；所有里面的内容时无法重复的，在使用EnumSet的时候是不能直接使用关键字new为其进行实例化的，所有再次类中提供了很多的静态方法。
			常用方法：
				public static <E extends Enum<E>> EnumSet<E> allOf(Class<E> elementType)
					将枚举中的全部内容设置到EnumSet之中；
				public static <E extends Enum<E>> EnumSet<E> of(E first, E... rest)
					创建一个包含枚举指定内容的EnumSet对象；
				public static <E extends Enum<E>> EnumSet<E> copyOf(Collection<E> c)
					创建一个从指定Collection中指定的EnumSet对象；
				public static <E extends Enum<E>> EnumSet<E> complementOf(EnumSet<E> s)
					创建一个其元素类型与指定枚举set相同的枚举set，最初包含指定集合中所不包含的此类型的所有元素；
				public static <E extends Enum<E>> EnumSet<E> noneOf(Class<E> elementType)
					创建一个可以接收指定类的空集合；
		
		小结：
			EnumMap和EnumSet：EnumMap是符合Map的操作形式的，而EnumSet基本上就是都使用静态方法完成；
			在操作中大量的使用了枚举.class，这个属于java发射机制；
		
反射机制：
	1.认识Class类：
		在正常情况下，必须知道一个类的完整路径之后才可以实例化对象，但是在java中也可以允许通过一个对象来找其所在的类的信息，
		这实际上就是Class类的功能。
		在Object类中定义了一下方法，此方法将被所有子类继承：
			public final Class getClass()
			此方法返回值的类型是一个“Class”类，实际上此类是Java反射的源头，实际上所谓反射从程序的运行结果来看也很好理解，即：
			以通过对象反射求出类的名称。
			
			正常方式：引入需要的“包.类”名称-->通过new实例化-->取得实例化对象
			反射方式：实例化对象-->getClass()方法-->得到完整的“包.类”名称
		
		Class类：本身表示一个类的本身，通过Class类可以完整的得到一个类中的完整结构，包括此类中的方法定义，属性定义等。
		常用方法：
			public static Class<?> forName(String className)throws ClassNotFoundException
				传入完整的“包.类”名称实例化Class对象；
			public Constructor[] getConstructors()throws SecurityException
				得到一个类中的全部构造方法；
			public Field[] getDeclaredFields()throws SecurityException
				得到一个类父类中的全部属性；
			public Field[] getFields()throws SecurityException
				得到本类的全部属性；
			public Method[] getMethods()throws SecurityException
				得到一个类中的全部方法；
			public Method getMethod(String name,Class... parameterTypes)throws NoSuchMethodException,SecurityException
				返回一个Method对象，并设置一个方法中的所有参赛类型；
			public Class[] getInterface()
				得到一个类中所实现的全部接口；
			public String getName()
				得到一个类完整的“包.类”名称；
			public Package getPackage()
				得到一个类的包；
			public Class getSuperclass()
				得到一个类的父类；
			publci Object newInstance()throws InstantiationException,IllegalAccessException
				根据Class定义的类实例化对象；
			public Class<?> getComponentType()
				返回表示数组类型的Class；
			public boolean isArray()
				判断此Class是否是一个数组；
				
		实例化Class类对象的方法有三种：
		   *1、通过forName()方法；
		   *2、类.class
			3、对象.getClass()方法
	
	2.Class类的使用：
		本章目标：
			可以使用Class类完成对象的实例化操作；
			可以通过Constructor类调用有参构造方法完成对象的实例化操作；
			
		Class主要是反射的源头，不光可以取得对象所在类的信息，也可以直接通过Class类的方法进行对象的实例化操作，正常情况下，使用关键字new为对象实例化；
		如果现在已经实例化好了Class对象，就可以通过Class类中的newInstance()方法完成对象的实例化。
			
		 即使不通过关键字new对象也可以进行实例化操作，反射的作用；
		 但是，在使用以上操作的时候有一点必须注意，在操作类中必须存在无参构造方法。
		 否则无法实例化。
		 如果想要调用有参的构造，则必须按照以下的步骤进行：
		 		1.通过Class类中的getConstructors()取得本类中的全部构造方法；
		  		2.向构造方法中传递一个对象数组进去，里面包含了构造方法中所需的各个参数；
		  		3.之后通过Constructor实例化对象；
	
		Constructor常用方法：
			public int getModifiers()
				得到构造方法的修饰符；
			public String getName()
				得到构造方法的名称；
			public Class<?>[] getParameterTypes()
				得到构造方法中参数的类型；
			public String toString()
				返回此构造方法的信息；
			public T newInstance(Object... initargs)throws InstantiationException,IllegalAccessException,IllegalArgumentException,InvocationTargetException
				向构造方法中传递参数，实例化对象；
	
		从实际角度看，如果要使用反射进行对象的实例化操作时，最好在类中存在无参构造。
	
	3.反射应用--取得类的结构：
		本章目标：
			可以使用反射取得实现的全部接口；
			可以使用反射取得一个类所继承的父类；
			可以使用反射取得一个类的全部构造方法；
			可以使用反射取得一个类中的全部方法；
			可以使用反射取得一个类中的全部属性；
			
		通过反射得到一个类的完整结构，就要使用到java.lang.reflect包中的以下几个类：
			Constructor：表示类中的构造方法；
			Field：表示类中的属性；
			Method：表示类中的方法；
		这三个类都是AccessibleObject类的子类；
		
	   *如果想要取得一个类所实现的全部接口，可以使用Class类中的：
			public Classs<?>[] getInstances()
			因为一个类可以同时实现多个接口，所以在此处将以一个数组的形式返回实现的全部接口。
	
	   *如果想要取得一个类的父类，可以直接使用Class类中的getSuperclass()方法。
			public Class<? super T> getSuperclass()
			此方法返回的是Class实例，和之前得到的接口一样，可以通过getName方法取得名称。
	
	   *如果想要取得一个类的全部构造方法，可以使用Class类中的：
			public Class<?> getConstructors()
			
	   *如果想要取得一个类的全部方法，可以使用Class类中的getDeclaredMethods()方法，
			public Method[] getDeclaredMethods()throws SecurityException
				取得本类中的全部方法；
			public Method[] getMethods()throws SecurityException
				取得所有类（包括父类）中的全部方法；
			此方法返回一个Method类的对象数组，而如果要想进一步取得方法的具体信息；
			例如：方法的参数，抛出的异常声明等等，则就必须依靠Method类；
	
	   *如果想要取得一个类中的全部属性，有以下两种操作：
			public Field[] getFields()throws SecurityException
				得到实现的接口或父类中的公共属性；
			public Field[] getDeclaredFields()throws ScecurityException
				得到本类中的全部属性；
			以上方法返回的都是Field的数组，每一个Field对象就表示类中的一个属性；
	
	4.反射机制的深入研究；
		本章目标：
			使用反射调用类中的指定方法；
			使用反射完成setter及getter方法的调用；
			使用反射直接操作类中的属性；
			使用反射操作数组；
		在正确情况下一个类的对象功能产生之后，就可以直接调用类中的方法了，如果要想调用的话，
		则肯定必须清楚的知道要调用的方法的名称是什么，之后通过Class类中的getMethod()方法，
		得到一个方法的Method对象，之后通过此Method对象来执行方法，但是在方法调用的时候，
		因为会牵扯到方法中的参数问题，所以通过getMethod()取得的时候，必须设置好需要的参数类型。
		执行调用的方法为：invoke()方法，执行调用的时候需传入参数进去，实例化对象。
		
		如果一个类的属性被封装，则必须通过setter和getter方法设置和取得。
	
		如果现在要操作一个类中的属性，则也可以通过Filed完成，不必麻烦的通过setter及getter方法。
			通过getField(String name)方法得到公共属性；
			通过getDeclaredField(String name)得到本类属性；
			通过set(Object obj,String name)方法设置属性
			在访问私有属性的时候，必须让这个属性可见：setAccessible(true)
			最好是通过setter和getter方法完成调用。
			
		反射机制不光可以使用在类中，也可以应用在任意的引用数据类型上，当然，这就包含了数组，数组使用Array类完成；
		Class类中存在以下一个方法：
			public Class<?> getComponentType()
				返回一个数组；
			public Static Object get(Object array,int index)throws IlleaglArgumentException,ArrayIndexOutOfBoundsException
				得到数组指定下标的内容；
			public static void set(Object array,int index,Object value)throws IllegalArgumentException,ArrayIndexOutOfBoundsException
				修改内容；
			public Static Object newInstance(Class<?> componentType,int... dimensions)throws IllegalArgumentException,NegativeArraySizeException
				开辟新数组；
	
	5.动态代理：
		本章目标：
			掌握动态代理的作用；
			掌握InvocationHandler接口和Proxy类的作用；
		代理设计：
			一个操作的接口有两个子类：一个是真实主题的实现类；另一个时代理类，代理实现类要完成比真实主题实现类更多的内容，
			而且本身还需要处理一些与具体业务有关的程序代码。
		
		静态代理：
			一个代理类只能为一个接口服务；
		动态代理：
			通过一个代理类完成全部的代理功能；
			在java中要想实现动态代理机制，则需要：
				java.lang.reflect.InvocationHandler接口和java.lang.reflect.Proxy类的支持；
			InvocationHandler接口：
				public interface InvocationHandler{
					public Object invoke(Object Proxy,Method method,Object[] args)throws Throwalbe
				}
				*参数说明：
					Object proxy：被代理的对象；
					Method method：要调用的方法；
					Object args[]：方法调用时所需要的参数；
				可以将InvocationHandler接口的子类想象成一个代理的最终操作类，替换掉ProxySubject。
	
		Proxy类：
			Proxy类是专门完成代理的操作类，可以通过此类为一个或多个接口动态的生成实现类，此类提供了如下的操作方法：
				public static Object newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h)throws IllegalArgumentException
			参数说明：
				ClassLoaderloader：类加载器；
				Class<?> interfaces：得到全部的接口；
				InvocationHandler h：得到InvocationHandler接口的子类实例；
				
			提示：类加载器：
				在Proxy类中的newProxyInstance()方法中需要一个ClassLoader类的实例，ClassLoader实际上对应的是类加载器，在java中主要有以下三种类加载器：
					1.Bootstrap ClassLoader：此加载器采用C++编写，一般开发中是看不到的；
					2.Extension ClassLoader：用来进行扩展类的加载，一般对应的是jre/lib/ext目录中的类；
					3.APPClassLoader：加载classpath指定的类，时最常使用的一种加载器。
			如果想要得到一个加载器的对象，需要使用Class类完成。
	
	6.工厂设计模式：
		工厂设计模式的最大好处是可以在应用中进行解耦合操作。
		如果此时希望在扩充子类时不用修改工厂类的话，则就必须使用反射完成。
		但是在使用反射的时候输入完整的“包.类”名称的话，肯定很麻烦，所有可以通过一些配置文件的方式保存这些完整的路径。	
		程序运行的时候，就可以将属性文件的内容读取出来，之后直接操作属性文件中的key，就可以避免输入过长的类路径。
		以上的程序达到了配置文件与程序代码相分离的目的；
	 	那么这种设计思路时以后开发的基本思路；
	 	当然，最新的设计理念：是在程序中直接通过注释的方式进行配置；
	
	
	
	
	
	
	
	
	
	
	
	
在dos窗口中打包：
	在文件所在目录：
		javac -d . 文件名.java //打包
		java 路径.文件名
			
			