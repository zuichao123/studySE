java类集：
	类集实际上就是一个动态的对象数组，与一般的对象数组不同，类集中的对象内容可以任意扩充。
	类集的特征：
		1.这种框架是高性能的；
		2.框架必须允许不同类型的类集以相同的方式和高度互操作方式工作；
		3.类集必须是容易扩展和修改的。
	对象数组中包含一组对象，但是对象数组使用的时候存在一个长度的限制，那么类集是专门解决这种限制的，使用类集可以方便的向数组中增加任意多个数据。
	类集框架主要接口：
		Collection：存放对象
			是存放一组单值的最大接口，所谓的单值是指集合中的每个元素都是一个对象。一般很少会直接使用此接口直接操作；
		List：可重复
			是Collection接口的子接口，也是最常用的接口，此接口对Collection接口进行了大量的扩充，里面的内容是允许重复的；
		Set：不可重复
			是Collection接口的子接口，没有对Collection接口进行扩充，里面不允许存放重复内容；	
		Map：成对存放
			Map是存放一对值的最大接口，即，接口中的每一个元素都是一对，以key->value的形式保存。
		Iterator：
			集合的输出接口，用于输出集合中的内容，只能进行从前到后的单向输出；
		ListIterator：
			是Iterator的子接口，可以进行双向输出；
		Enumeration：
			是最早的输出接口，用于输出指定集合中的内容；
		SortedSet：
			单值的排序接口，实现此接口的集合类，里面的内容是可以排序的，使用比较器排序；
		SortedMap：
			存放一对值的排序接口，实现此接口的集合类，里面的内容按钮key排序，使用比较器排序；
		Queue：
			队列接口，此接口的子类可以实现对象操作；
		Map.Entry：
			Map.Entry的内部接口，每个Map.Entry对象都保存着一对key->value的内容，每个Map接口中都保存多个Map.Entry接口实例。
	
	以上接口必须全部掌握。
	
	1.Collection接口：java.util包中
		是保存单值集合的最大父接口；
		定义格式：		 
			public interface Collection<E> extends Iterable<E>
		常用方法：
			public boolean add(E o)
				向集合中插入对象；
			public boolean addAll(Collection<? extends E> c)
				将一个集合的内容插入进来；
			public void clear()
				清除此集合中所有元素；
			public boolean contains(Object o)
				判断某一个对象是否在集合中存在；
			public boolean containsAll(Collection<?> c)
				判断一组对象是否在集合中存在；
			public boolean equals(Object o)
				对象比较；
			public int hashCode()
				哈希码；
			public boolean isEmpty()
				判断集合是否为空；
			public Iterator<E> iterator()
				为Iterator接口实例化；
			public boolean remove(Object o)
				删除指定对象；
			public boolean removeAll(Collection<?> c)
				删除一组对象；
			public boolean retainAll(Collection<?> c)
				保存指定内容；
			public int size()
				求出集合的大小；
			public Object[] toArray()
				将一个集合变为对象数组；
			public <T> T[] toArray(T[] a) 
				指定好返回的对象数组类型；
		
		*Collection接口的使用注意：
			在一般开发中，往往很少直接使用Collection接口进行开发，因为表示的操作意义不明确。
			而基本上都是使用其子接口，主要有：List、Set、Queue、SortedSet。
				List接口：可以存放重复的内容；
				Set接口：不能存放重复的内容，所有的重复内容是靠hashCode()和equals()两个方法区分的；
				Queue接口：队列接口；
				SortedSet接口：可以对集合中的数据进行排序；
		
		1.1 List接口：可重复
			本章目标：
				1.掌握List接口与Collection接口的关系；
				2.掌握List接口的常用子类：ArrayList、Vector；
				3.掌握ArrayList与Vector类的区别；
			
			List接口是Collection接口的子接口，List接口中可以存放任意的数据。而且在List接口中内容是允许重复的。
			定义格式：
				public interface List<E> extends Collection<E>	
			常用（扩展）方法：
				public void add(int index, E element)
					在指定位置增加元素；
				public boolaen addAll(int index, Collection<? extends E> c)
					在指定位置增加一组元素；
				E get(int index)
					返回指定位置的元素；
				public int indexOf(Object o)
					查找指定元素的位置；
				public int lastIndexOf(Object o)
					从后向前查找指定元素的位置；
				public ListIterator<E> listIterator()
					为ListIterator接口实例化；
				public E remove(int index)
					按指定的位置删除元素；
				public List<E> subList(int fromIndex, int toIndex)
					取出集合中的子集合；截取部分集合：
				public E set(int index, E element)
					替换指定位置的元素；
			
			1.1.1 List接口的常用子类--ArrayList：是List接口中最常用的子类；
				ArrayList是List接口的子类，可以直接通过对象的多态性，为List接口实例化；
				此类的定义格式如下：
					public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, Serializable
					
				AbstractList类的定义如下：
					public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E>
					
			1.1.2 Vector类：是List接口的子类：
				考虑到大多数人已经习惯了Vector类，Java设计者就让Vector类实现了已List接口，这才将其保存下来。但是因为其实List接口的子类，所有Vector类的使用与之前的并没有太大的区别；
				Vector类的定义如下：
					public class Vector<E> extends AbstractList<E> implements List<E> RandomAccess, Cloneable, Serializable
					
			***子类的差异：ArrayList与Vector的区别：
				1.推出时间：
					ArrayList：JDK1.2之后推出的，属于新的操作类；
					Vector：JDK1.0时推出的，属于旧的操作类；
				2.性能：
					ArrayList：采用异步处理的方式；
					Vector：采用同步的方式，性能较低；
				3.线程安全：
					ArrayList：属于非线程安全的操作类；
					Vector：属于线程安全的操作类；
				4.输出：
					ArrayList：只能使用Iterator、foreach输出；
					Vector：可以使用Iterator、foreach、Enumeration输出；
			
		1.2 Queue接口与LinkedList子类：
			队列操作（对头永远是新增的内容，队尾永远是先出的内容）
			1.2.1 LinkedList表示的是一个链表的操作类，此类的定义如下：
	 				public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Queue<E>, Clineable, Serializable
	 			LinkedList子类的常用方法：
					public void addFirst(E o)
						在链表开头增加元素；
					public vlid addLast(E o)
						在链表结尾增加元素；
					public boolean offer(E o)
						将指定元素增加到链表的结尾；
					public E removeFirst()
						删除链表的第一个元素；
					public E removeLast()
						删除链表的最后一个元素；
	 			LinkedList本身大量扩充了Queue接口和List接口的操作，所有在使用时最好直接使用LinkedList类完成操作。
	 		1.2.2 Queue接口是Collection的子接口，此接口定义如下：
	 				public interface Queue<E> extends Collection<E>	
				Queue接口的常用方法：
					public E element()
						找到链表的表头；
					public boolean offer(E o)
						将指定元素增加到链表的结尾；
					public E peek()
						找到但并不删除链表的头；
					public E poll()
						找到并删除链表的头；
					public E remove()
						检索并移除表头；
			
		1.3 Set接口：不可重复
			掌握：
				treeSet的排序原理；
				Set接口中重复元素的定义；
		
			Set接口也是Collection接口的子接口，但是与Collection或List接口不同的是，Set接口中不能加入重复的元素；
			Set接口的定义：
				public interface Set<E> extends Collection<E>
			Set接口的主要方法与Collection是一致的；
			Set接口的实例无法像List接口那样进行双向输出；因为没有提供get()方法；
			Set接口的常用子类：
				散列存放：HashSet
				有序存放：TreeSet
			
			 如果想要取消掉重复元素，则需要Object类中的两个方法帮助：
			 	*1.hashCode()：表示一个唯一的编码，一般通过计算表示；
			 	*2.equals()：进行对象的比较操作；
			 	
			 小结：
			 	Set接口依靠hashCode()和equals()完成重复元素的判断，关于这一点在日后的Map接口中也有体现；
			 	TreeSet依靠Compatable接口完成排序操作。
			
		1.4 SortedSet接口：排序接口
			TreeSet实际上也是SortedSet接口的子类：所以此接口的所有类都是可以排序的。
			SortedSet接口的定义如下：
				public interface SortedSet<E> extends Set<E>
			SortedSet接口中定义的方法：
				public Comparator<? super E> comparator()
					返回与排序有关联的比较器；
				public E first()
					返回集合中的第一个元素；
				public SortedSet<E> headSet(E toElement)
					返回从开始到指定元素的集合；
				public E last()
					返回最后一个元素；
				public SortedSet<E> subSet(E fromElement,E toElement)
					返回指定对象间的元素；
				public SortedSet<E> tailSet(E fromElement)
					从指定元素到最后；
					
			只要看到了SortedSet开头的接口，就是可以排序的接口。（按照Comparable排序）
			
		*1.5 Iterator接口：集合输出接口（从前向后输出，属于单向的输出）
			在集合的输出操作中，支持以下几种方式：
				1.Iterator
				2.ListIterator
				3.foreach
				4.Enumeration
			Iter接口简介：
				1.集合输出的标准操作：
					在使用集合输出的时候必须形成以下的一个思路：只要是碰到了集合输出的操作，就一定使用Iterator接口，因为这是最标准的做法；
				2.Iterator接口的操作原理：
					Iterator是专门的迭代输出接口，所谓的迭代输出就是将元素一个个进行判断，判断其是否有内容，如果有内容则把内容取出。
			
			对于Iterator而言，因为其本身是一个接口，所有要想实例化则必须依靠Collection接口完成。
			常用方法：
				public boolean hasNext()
					正向判断是否有内容；
				public E next()
					取出内容；
				public void remove()
					删除当前元素；
			
			如果在迭代输出过程中使用了List中的remove()执行删除操作，则代码将出现问题。
			在使用iterator输出时，不要使用集合类中的remove方法，而只能使用Iterator的remove方法。
			iterator接口的功能时从前向后输出，属于单向的输出；
			在使用iterator时，最后不要删除数据。
		
		1.6 ListIterator接口：集合输出接口（是Iterator的子接口，双向输出）
			是Iterator接口的子接口，主要功能实现了右前向后、右后向前的双向输出；
			ListIterator接口的定义如下：
				public interface ListIterator<E> extends Iterator<E>
			此接口可以进行双向输出操作，但是在Collection接口中并没有定义可以为此类实例化的操作，只有List接口中才存在了ListIterator接口的实例化操作（通过调用ListIterator()方法实现）。
			常用方法：
				public void add(E e)
					添加操作，将指定元素插入列表；
				public boolean hasPrevious()
					逆向判断是否有内容；
				public E previous()
					返回列表中的前一个元素
				public void set(E e)
					用指定元素替换next或previous返回的最后一个元素；
			
			注意：此操作时，必须先进行由前向后，再进行右后向前的操作。
		                            如果要想使用ListIterator接口，则只能依靠List接口完成；
			
		1.7 foreach及Enumeration接口：
			foreach输出：
				List<String> allList = new ArrayList<String>();
			
				allList.add("hello");
				allList.add("_");
				allList.add("world");
				
				for(String str : allList){
					System.out.print(str+"、");
				}
			
			Enumeration接口：
				在Java刚出来的时候，使用Enumeration接口完成输出；
				在使用Enumeration输出的时候一般都是直接操作Vector类完成的。
				常用方法：
					public boolean hasMoreElements()
						判断是否有内容；
					public E nextElement()
						输出内容
			注意：在所有的输出操作红，以Iterator接口为最标准的输出操作；
		
	*2.Map接口：	
		本章目标：
			1.掌握Map接口与Collection接口的不同；
			2.掌握Map接口与Map.Entry接口的关系；
			3.掌握Map接口的常用子类：HashMap、Hashtable、TreeMap、WeakHashMap；
			4.掌握HashMap与Hastable的区别。
		之前所讲解的Collection、Set、List接口都属于单值的操作，即每一次只能操作一个对象，而Map与他们不同的是，每次操作的是一对对象，即二元偶对象；
		Map中保存的是一对对象，对象的形式以：key-->value的形式保存的。此接口的定义如下：
			public interface Map<K,V>
		常用方法：
			public void clear()
				清空Map集合；
			public boolean containsKey(Object key)
				判断指定的key是否存在；
			public boolean containsValue(Object value)
				判断指定的value是否存在；
			public Set<Map.Entry<K,V>> entrySet()
				将Map对象变为Set集合；
			public boolean equals(Object o)
				对象比较；
			public V get(Object key)
				根据key取得value；
			public int hashCode()
				返回哈希码；
			public boolean isEmpty()
				判断集合是否为空；
			public Set<K> keySet()
				取得所有的key；
			public V put(K key, V value)
				向集合中加入元素；
			public void putAll(Map<? extends K, ? extends V> t)
				将一个Map集合中的内容加入到另一个Map；
			public V remove(Object key)
				根据key删除value；
			public int size()
				取出集合的长度；
			public Collection<V> values()
				取出全部的value；
		
		Map接口的常用子类：
			1.HashMap：无序存放的，是新的操作类，key不允许重复；
			2.Hashtable：无效存放的，是旧的操作类，key不允许重复；
			3.TreeMap：可以排序的Map集合，按集合中的key排序，key不允许重复。
			4.WeakHashMap：弱引用的Map集合，当集合中的某些内容不再使用时，可以清除掉无用的数据，可以使用gc进行回收；
			5.IdentityHashMap：key可以重复的Map集合；
			
		HashMap与Hashtable的区别：
			1.推出时间：
				HashMap：JDK1.2之后推出的，属于新的操作类；
				Hashtable：JDK1.0时推出的，属于旧的操作类；
			2.性能：
				HashMap：采用异步处理方式，性能更高；
				Hashtable：采用同步处理方式，性能较低；
			3.线程安全：
				HashMap：属于非线程安全操作类；
				Hashtable：属于线程安全的操作类；
			
		如果自定义的类要想作为key的话，则肯定要实现Comparable接口，指定比较规则。	
			
		对象引用的强度说明：
			从JDK1.2版本开始，Java把对象的引用分为四种级别，从而使程序能更加灵活的控制对象的声明周期。这四种级别又高到底依次是：
			强引用、软引用、弱引用、虚引用，这四种引用的区别如下：
				强引用：当内存不足时，jvm宁可出现OutOfMemeryError错误而使程序停止，也不会回收此对象来释放空间；
				软引用：当内存不足时，会回收这些对象的内存，用来实现内存敏感的高速缓存；
				弱引用：无论内存是否紧张，被垃圾回收器发现立即回收；
				虚引用：和没有任何引用一样。	
		
		2.1 Map.Entry接口：
			Map.Entry是Map中内部定义的一个接口，专门用来保存key―>value的内容。
			Map.Entry接口的定义格式：
				public static interface Map.Entry<K, V>
			Map.Entry接口的常用方法：
				public boolean equals(Object o)
					对象比较；
				public K getKey()
					取得key；
				public V getValue()
					取得value；
				public int hashCode()
					返回哈希码；
				public V setValue(V value)
					设置value的值；
		
		**小结：
			Map是Java中的接口，Map.Entry时Map的一个内部接口，java.util.Map.Entry接口主要就是在遍历Map的时候用到；
			Map提供了一些常用方法：
				keySet():返回的是Map中key值的集合；
				entrySet():返回的是类型为Map.Entry的Set集合；
			Map.Entry接口为泛型，表示Map中的一个实体（一个key-value对），接口中有getKey()方法和getValue()方法。
			Map的主要功能就是查找，根据key找到value。
		
		2.2 Map接口使用的注意事项：
			1.掌握Map接口的输出操作；
			2.掌握Map接口中key类的定义标准；
			
			对应Map接口来说，其本身是不能直接使用迭代（例如：Iterator、foreach）进行输出的，因为Map中的每一个位置存放的是一对值（key―value），而Iterator中每次只能找到一个值。
			如果非要使用迭代输出的话，则必须按照以下步骤完成（以Iterator输出方法为例：）：
				1.将Map的实例通过entrySet()方法变为Set接口对象；
				2.通过Set接口实例为Iterator实例化；
				3.通过Iterator迭代输出，每个内容都是Map.Entry的对象；
				4.通过Map.Entry进行key-value的分离。
		
			注意：直接使用非系统类作为key；
				如果要使用非系统类作为Map的key，则此类必须覆写Object类中的以下两个方法：
					1.hashCode()
					2.equals()
			
		2.3 IdentityHashMap类：
			在正常的map操作中，key本身是不能重复的；
			如果现在要求key的值可以重复，就要使用IdentityHashMap类；
			
		2.4 SortedMap类：
			集合排序：是TreeMap集合的父类；
			常用扩展方法：
				public Comparator<? super K> comparator()
					返回比较器对象；
				public K firstKey()
					返回第一个元素key；
				public SortedMap<K, V> headMap(K toKey)
					返回小于等于指定key的部分集合；
				public K lastKey()
					返回最后一个元素的key；
				public SortedMap<K, V> subMap(K fromKey, K toKey)
					返回指定key范围的集合；
				public SortedMap<K, V> tailMap(K fromKey)
					返回大于指定key的部分集合；
		
	3.集合工具类：Collections
		Collections与Collection没有直接关系，但是与集合中的各个接口都有操作的方法支持。
		在集合的应用开发中，集合的若干接口和若干子类时最最常使用的，但是在jdk中提供了一种集合操作的工具类--Collections，可以直接通过此类方便的操作集合。
		Collections类的定义如下：
			public class Collections extends Object
		
		Collections类的常用方法及常量：
			public static final List EMPTY_LIST
				返回一个空的List集合；
			public static final Set EMPTY_SET
				返回空的Set集合；
			public static final Map EMPTY_MAP
				返回空的Map集合；
			public static <T> boolean addAll(Collection<? super T> c, T...a)
				为集合添加内容；
			public static <T extends Object & Comparable<? super T>> T max(Collection<? extends T> coll)
				找到集合中最大的内容，按比较器排序；
			public static <T extends Object & Comparable<? super T>> T min(Collection<? extends T> coll)
				找到集合中最小的内容，按比较器排序；
			public static <T> boolean replaceAll(List<T> list, T oldVal, T newVal)
				用新的内容替换集合中的指定内容；
			public static void reverse(List<?> list)
				集合反转；
			public static <T> int binarySearch(List<? extends Comparable<? super T>> list, T key)
				查找集合中的指定内容；
			public static final <T> List<T> emptyList()
				返回一个空的List集合；
			public static final <K,V> Map<K,V> emptyMap()
				返回一个空的Map集合；
			public static final <T> Set<T> emptySet()
				返回一个空的Set集合；
			public static <T extends Comparable<? super T>> void sort(List<T> list)
				集合排序操作，根据Comparable接口进行排序；
			public static void swap(List<?> list,int i,int j)
				交换指定位置的元素；
	
	4.Stack类：
		栈是采用先进后出的数据存储方式，每一个栈都包含一个栈顶，每次出栈是将栈顶的数据取出；
		在java中使用Stack类进行栈的操作，Stack类是Vector的子类；
		Stack类的定义如下：
			public class Stack<E> extends Vector<E>
		常用方法：
			public boolean empty()
				测试栈是否为空；
			public E peek()
				查看栈顶，但不删除；
			public E pop()
				出栈，同时删除；
			public E push(E item)
				入栈；
			public int search(Object o)
				在栈中查找；	
	
	5.属性类Properties：
		Properties是Hashtable的子类，则也是Map的子类，可以使用Map的全部操作，但是在一般情况下属性类是单独使用的；	
		常用方法：
			public Object setProperty(String key, String value)
				设置属性；
			public String getProperty(String key)
				得到属性；
			public String getProperty(String key,String defaultValue)
				得到默认值，同时设置默认值；	
			public void store(OutputStream out,String comments)throws IOException
				将属性写入普通文件；
			public void load(InputStream inStream)throws IOException
				读取普通文件中的属性信息；
			public void storeToXML(OutputStream out,String comments)throws IOException
				将属性写入xml文件；
			public void loadFromXML(InputStream inStream)throws IOException
				读取xml文件中的属性信息；
		小结：	
			通过后续学习的java反射机制部分，了解属性类的应用；
			属性中的类型都是字符串，因为方便操作；
		
枚举：	enumeration	
	所谓的枚举就是规定好了指定的取值范围，所有的内容只能从指定的范围中取得。
	在JDK1.5之后，引入了一个新的关键字类型--enum，可以直接定义枚举格式，格式如下：
		[public] enum 枚举类型名称{
			枚举对象1,枚举对象2,枚举对象3,....,枚举对象n;
		}
	因为枚举已经指定好了范围，所有可以使用foreach进行全部的输出，使用“枚举.values()”的形式取得全部的枚举内容。	
	小结；
		使用枚举，可以限定取值的范围；
		使用enum关键字可以定义枚举；
	
	1.Enum类：
		使用enum可以定义一个枚举，实际上此关键字表示的是java.lang.Enum类型，即:使用enum声明的枚举类型，就相当于定义一个类，而此类则默认继承java.lang.Enum类。
		java.lang.Enum类的定义如下：
			public abstract class Enum<E extends Enum<E>> extends Object implements Comparable<E>, java.io.Serializable
		此种类型是可以比较、排序、可以序列化的。	
		枚举类的主要操作方法：
			protected Enum(String name,int ordinal)
				构造，接收枚举的名称和枚举的常量创建枚举对象；（一个表示枚举的名字，一个表示枚举的序号）
			protected final Object clone()throws CloneNotSupportedException
				克隆枚举对象；
			public final int compareTo(E o)
				对象比较；
			public final boolean equals(Object other)
				比较两个枚举对象；
			public final int hashCode()
				返回枚举常量的哈希码；
			public final String name()
				返回此枚举常量的序数；
			public static <T extends Enum<T>> T valueOf(Class<T> enumType,String name)
				返回带指定名称的指定枚举类型的枚举常量；
		一旦定义有参构造之后，在声明枚举对象的时候就必须明确的调用构造方法，并传递参数。
		
	2.类集对Enum的支持：
		2.1掌握EnumMap类的使用；
			Map接口的子类；
			定义如下：
				public class EnumMap<K extends Enum<K>,V> extends AbstractMap<K,V> implements Serializable, Cloneable
				
		2.2掌握EnumSet类的使用；
			Set接口的子类；所有里面的内容时无法重复的，在使用EnumSet的时候是不能直接使用关键字new为其进行实例化的，所有再次类中提供了很多的静态方法。
			常用方法：
				public static <E extends Enum<E>> EnumSet<E> allOf(Class<E> elementType)
					将枚举中的全部内容设置到EnumSet之中；
				public static <E extends Enum<E>> EnumSet<E> of(E first, E... rest)
					创建一个包含枚举指定内容的EnumSet对象；
				public static <E extends Enum<E>> EnumSet<E> copyOf(Collection<E> c)
					创建一个从指定Collection中指定的EnumSet对象；
				public static <E extends Enum<E>> EnumSet<E> complementOf(EnumSet<E> s)
					创建一个其元素类型与指定枚举set相同的枚举set，最初包含指定集合中所不包含的此类型的所有元素；
				public static <E extends Enum<E>> EnumSet<E> noneOf(Class<E> elementType)
					创建一个可以接收指定类的空集合；
		
		小结：
			EnumMap和EnumSet：EnumMap是符合Map的操作形式的，而EnumSet基本上就是都使用静态方法完成；
			在操作中大量的使用了枚举.class，这个属于java发射机制；
		
反射机制：
	1.认识Class类：
		在正常情况下，必须知道一个类的完整路径之后才可以实例化对象，但是在java中也可以允许通过一个对象来找其所在的类的信息，
		这实际上就是Class类的功能。
		在Object类中定义了一下方法，此方法将被所有子类继承：
			public final Class getClass()
			此方法返回值的类型是一个“Class”类，实际上此类是Java反射的源头，实际上所谓反射从程序的运行结果来看也很好理解，即：
			以通过对象反射求出类的名称。
			
			正常方式：引入需要的“包.类”名称-->通过new实例化-->取得实例化对象
			反射方式：实例化对象-->getClass()方法-->得到完整的“包.类”名称
		
		Class类：本身表示一个类的本身，通过Class类可以完整的得到一个类中的完整结构，包括此类中的方法定义，属性定义等。
		常用方法：
			public static Class<?> forName(String className)throws ClassNotFoundException
				传入完整的“包.类”名称实例化Class对象；
			public Constructor[] getConstructors()throws SecurityException
				得到一个类中的全部构造方法；
			public Field[] getDeclaredFields()throws SecurityException
				得到一个类父类中的全部属性；
			public Field[] getFields()throws SecurityException
				得到本类的全部属性；
			public Method[] getMethods()throws SecurityException
				得到一个类中的全部方法；
			public Method getMethod(String name,Class... parameterTypes)throws NoSuchMethodException,SecurityException
				返回一个Method对象，并设置一个方法中的所有参赛类型；
			public Class[] getInterface()
				得到一个类中所实现的全部接口；
			public String getName()
				得到一个类完整的“包.类”名称；
			public Package getPackage()
				得到一个类的包；
			public Class getSuperclass()
				得到一个类的父类；
			publci Object newInstance()throws InstantiationException,IllegalAccessException
				根据Class定义的类实例化对象；
			public Class<?> getComponentType()
				返回表示数组类型的Class；
			public boolean isArray()
				判断此Class是否是一个数组；
				
		实例化Class类对象的方法有三种：
		   *1、通过forName()方法；
		   *2、类.class
			3、对象.getClass()方法
	
	2.Class类的使用：
		本章目标：
			可以使用Class类完成对象的实例化操作；
			可以通过Constructor类调用有参构造方法完成对象的实例化操作；
			
		Class主要是反射的源头，不光可以取得对象所在类的信息，也可以直接通过Class类的方法进行对象的实例化操作，正常情况下，使用关键字new为对象实例化；
		如果现在已经实例化好了Class对象，就可以通过Class类中的newInstance()方法完成对象的实例化。
			
		 即使不通过关键字new对象也可以进行实例化操作，反射的作用；
		 但是，在使用以上操作的时候有一点必须注意，在操作类中必须存在无参构造方法。
		 否则无法实例化。
		 如果想要调用有参的构造，则必须按照以下的步骤进行：
		 		1.通过Class类中的getConstructors()取得本类中的全部构造方法；
		  		2.向构造方法中传递一个对象数组进去，里面包含了构造方法中所需的各个参数；
		  		3.之后通过Constructor实例化对象；
	
		Constructor常用方法：
			public int getModifiers()
				得到构造方法的修饰符；
			public String getName()
				得到构造方法的名称；
			public Class<?>[] getParameterTypes()
				得到构造方法中参数的类型；
			public String toString()
				返回此构造方法的信息；
			public T newInstance(Object... initargs)throws InstantiationException,IllegalAccessException,IllegalArgumentException,InvocationTargetException
				向构造方法中传递参数，实例化对象；
	
		从实际角度看，如果要使用反射进行对象的实例化操作时，最好在类中存在无参构造。
	
	3.反射应用--取得类的结构：
		本章目标：
			可以使用反射取得实现的全部接口；
			可以使用反射取得一个类所继承的父类；
			可以使用反射取得一个类的全部构造方法；
			可以使用反射取得一个类中的全部方法；
			可以使用反射取得一个类中的全部属性；
			
		通过反射得到一个类的完整结构，就要使用到java.lang.reflect包中的以下几个类：
			Constructor：表示类中的构造方法；
			Field：表示类中的属性；
			Method：表示类中的方法；
		这三个类都是AccessibleObject类的子类；
		
	   *如果想要取得一个类所实现的全部接口，可以使用Class类中的：
			public Classs<?>[] getInstances()
			因为一个类可以同时实现多个接口，所以在此处将以一个数组的形式返回实现的全部接口。
	
	   *如果想要取得一个类的父类，可以直接使用Class类中的getSuperclass()方法。
			public Class<? super T> getSuperclass()
			此方法返回的是Class实例，和之前得到的接口一样，可以通过getName方法取得名称。
	
	   *如果想要取得一个类的全部构造方法，可以使用Class类中的：
			public Class<?> getConstructors()
			
	   *如果想要取得一个类的全部方法，可以使用Class类中的getDeclaredMethods()方法，
			public Method[] getDeclaredMethods()throws SecurityException
				取得本类中的全部方法；
			public Method[] getMethods()throws SecurityException
				取得所有类（包括父类）中的全部方法；
			此方法返回一个Method类的对象数组，而如果要想进一步取得方法的具体信息；
			例如：方法的参数，抛出的异常声明等等，则就必须依靠Method类；
	
	   *如果想要取得一个类中的全部属性，有以下两种操作：
			public Field[] getFields()throws SecurityException
				得到实现的接口或父类中的公共属性；
			public Field[] getDeclaredFields()throws ScecurityException
				得到本类中的全部属性；
			以上方法返回的都是Field的数组，每一个Field对象就表示类中的一个属性；
	
	4.反射机制的深入研究；
		本章目标：
			使用反射调用类中的指定方法；
			使用反射完成setter及getter方法的调用；
			使用反射直接操作类中的属性；
			使用反射操作数组；
		在正确情况下一个类的对象功能产生之后，就可以直接调用类中的方法了，如果要想调用的话，
		则肯定必须清楚的知道要调用的方法的名称是什么，之后通过Class类中的getMethod()方法，
		得到一个方法的Method对象，之后通过此Method对象来执行方法，但是在方法调用的时候，
		因为会牵扯到方法中的参数问题，所以通过getMethod()取得的时候，必须设置好需要的参数类型。
		执行调用的方法为：invoke()方法，执行调用的时候需传入参数进去，实例化对象。
		
		如果一个类的属性被封装，则必须通过setter和getter方法设置和取得。
	
		如果现在要操作一个类中的属性，则也可以通过Filed完成，不必麻烦的通过setter及getter方法。
			通过getField(String name)方法得到公共属性；
			通过getDeclaredField(String name)得到本类属性；
			通过set(Object obj,String name)方法设置属性
			在访问私有属性的时候，必须让这个属性可见：setAccessible(true)
			最好是通过setter和getter方法完成调用。
			
		反射机制不光可以使用在类中，也可以应用在任意的引用数据类型上，当然，这就包含了数组，数组使用Array类完成；
		Class类中存在以下一个方法：
			public Class<?> getComponentType()
				返回一个数组；
			public Static Object get(Object array,int index)throws IlleaglArgumentException,ArrayIndexOutOfBoundsException
				得到数组指定下标的内容；
			public static void set(Object array,int index,Object value)throws IllegalArgumentException,ArrayIndexOutOfBoundsException
				修改内容；
			public Static Object newInstance(Class<?> componentType,int... dimensions)throws IllegalArgumentException,NegativeArraySizeException
				开辟新数组；
	
	5.动态代理：
		本章目标：
			掌握动态代理的作用；
			掌握InvocationHandler接口和Proxy类的作用；
		代理设计：
			一个操作的接口有两个子类：一个是真实主题的实现类；另一个时代理类，代理实现类要完成比真实主题实现类更多的内容，
			而且本身还需要处理一些与具体业务有关的程序代码。
		
		静态代理：
			一个代理类只能为一个接口服务；
		动态代理：
			通过一个代理类完成全部的代理功能；
			在java中要想实现动态代理机制，则需要：
				java.lang.reflect.InvocationHandler接口和java.lang.reflect.Proxy类的支持；
			InvocationHandler接口：
				public interface InvocationHandler{
					public Object invoke(Object Proxy,Method method,Object[] args)throws Throwalbe
				}
				*参数说明：
					Object proxy：被代理的对象；
					Method method：要调用的方法；
					Object args[]：方法调用时所需要的参数；
				可以将InvocationHandler接口的子类想象成一个代理的最终操作类，替换掉ProxySubject。
	
		Proxy类：
			Proxy类是专门完成代理的操作类，可以通过此类为一个或多个接口动态的生成实现类，此类提供了如下的操作方法：
				public static Object newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h)throws IllegalArgumentException
			参数说明：
				ClassLoaderloader：类加载器；
				Class<?> interfaces：得到全部的接口；
				InvocationHandler h：得到InvocationHandler接口的子类实例；
				
			提示：类加载器：
				在Proxy类中的newProxyInstance()方法中需要一个ClassLoader类的实例，ClassLoader实际上对应的是类加载器，在java中主要有以下三种类加载器：
					1.Bootstrap ClassLoader：此加载器采用C++编写，一般开发中是看不到的；
					2.Extension ClassLoader：用来进行扩展类的加载，一般对应的是jre/lib/ext目录中的类；
					3.APPClassLoader：加载classpath指定的类，时最常使用的一种加载器。
			如果想要得到一个加载器的对象，需要使用Class类完成。
	
	6.工厂设计模式：
		工厂设计模式的最大好处是可以在应用中进行解耦合操作。
		如果此时希望在扩充子类时不用修改工厂类的话，则就必须使用反射完成。
		但是在使用反射的时候输入完整的“包.类”名称的话，肯定很麻烦，所有可以通过一些配置文件的方式保存这些完整的路径。	
		程序运行的时候，就可以将属性文件的内容读取出来，之后直接操作属性文件中的key，就可以避免输入过长的类路径。
		以上的程序达到了配置文件与程序代码相分离的目的；
	 	那么这种设计思路时以后开发的基本思路；
	 	当然，最新的设计理念：是在程序中直接通过注释的方式进行配置；
	
Annotation：元数据特性，即：使用注释的方式加入一些程序的信息；
	了解Annotation的作用；
	掌握系统内建的三个Annotation；
	
	1.系统内建的Annotation：	
		java.lang.annotation.Annotation接口是所有的Annotation都必须实现的接口。
		
		在JDK1.5之后，系统中已经建立了如下的三个内建的Annotation类型，用户直接使用即可。
			1. @Override：覆写的Annotation；
				表示方法覆写的正确性，可以保证程序正确的执行；
				java中声明：
					@Target(value = METHOD)
					@Retention(value = SOURCE)
					public @interface Override
			2. @Deprecated：不赞成使用的Annotation；
				编译时不会出错，而是出现一个警告信息；也可以用在类上；
				java中声明：
					@Documented
					@Retention(value = RUNTIME)
					public @interface Deprecated
			3. @SuppressWarnings：压制安全警告的Annotation；
				也可以压制多个警告，可以通过数组是形式
				java中声明：
					@Target(value = {TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE})
					@Retention(value = SOURCE)
					public @interface Suppress Warnings
				@SuppressWarnings中的关键字：
					1. deprecation：使用了不赞成使用的类或方法时的警告；
					2. unchecked：执行了未检查的转换时的警告，例如：泛型中没有指定泛型类型；
					3. fallthrough：当switch程序块直接通往下种情况而没有break时的警告；
					4. path：在类路径、源文件路径等中不存在的路径时警告；
					5. serial：当在可序列化的类上缺少serialVersionUID定义时的警告；
					6. finally：任何finally子句不能正常完成时的警告；
					7. all：关于以上所有情况的警告；
				在设置注释信息的时候，是以key->value的形式出现的，所以以上的@SuppressWarnings也可以直接使用“value = {"unchecked","deprecation"}”的方式设置；
				注释里边是使用value的字符串数组接收的，在传入注释参数的时候也可以明确的指出要传给那个变量接收；
				
	2.自定义的Annotation：
		本章目标：
			掌握自定义Annotation的简单格式；
			可以使用Annotation接收设置的内容；
			可以为Annotation中的变量指定默认值；
			可以使用枚举指定Annotation的取值范围；
			掌握Retention及RetentionPolicy的作用；
		Annotation的定义格式：
			public @interface Annotation名称{
				数据类型     变量名称();
			}	
			
		Annotation中有一个特点，所有的参数需要在使用的时候设置上去，那么也可以为一个参数设置默认的内容，在声明的使用使用default即可。
	
		2.1 Retention和RetentionPolicy：
			在Annotation，可以使用Retention定义一个Annotation的保存范围，此Annotation的定义如下：
				@Documented
				@Retention(value = RUNTIME)
				@Target(value = ANNOTATION_TYPE)
				public @interface Retention{
					RetentionPolicy value();
				}
			在以上的Rentetion定义中存在了一个RententionPolicy的变量，此变量用于指定Annotation的保存范围，RetentionPolicy包含一下三种范围：
				SOURCE：
					此Annotation类型的信息只会保留在程序源文件之中(*.java)，编译之后不会保存在编译好的类文件(*.class)之中。
				CLASS：
					此Annotation类型将保留在程序源文件(*.java)和编译之后的类文件(*.class)之中，在使用此类的时候，这些Annotation信息将不会被加载到虚拟机(JVM)之中，如果一个Annotation声明时没有指定范围，则默认是此范围；
				RUNTIME：
					此Annotation类型的信息保留在源文件(*.java)、类文件(*.class)之中，在执行时也会加载到JVM之中；
	
			在三个范围中，最需要关心的是RUNTIME范围，因为执行的时候起作用。
	
		2.2 内建Annotation的RetentionPolicy：
			@Override：
				采用的是@Retention(value = SOURCE)，只能在源文件中出现；
			@Deprecated：
				采用的是@Retention(value = RUNTIME)，可以在执行时出现；
			@SuppressWarnings：
				采用的是@Retention(value = SOURCE)，只能在源文件中出现；
	
	3.反射与Annotation：
		本章目标：
			可以通过java反射机制取得使用的全部Annotation；
			可以通过java反射机制取得指定的Annotation；
		
		一个Annotation如果要想让其变得有意义，则必须结合反射机制取得Annotation中设置的全部内容；
		在Class类中存在以下几种Annotation操作有关的方法：
			public<A extends Annotation>A getAnnotation(Class<A> annotationClass)
				如果在一个元素中存在注释，则取得全部注释；
			public Annotation[] getAnnotations()
				返回此元素上的所有注释；
			public Annotation[] getDeclaredAnnotations()
				返回直接存放在此元素上的所有注释；
			public boolean isAnnotation()
				判断元素是否表示一个注释；
			public boolean isAnnotationPresent(Class<? extends Annotation> annotationClass)
				判断一个元素上是否存在注释；
	
	4.深入Annotation：
		本章目标：
			掌握@Target注释的作用；
			掌握@Documented注释的作用；
			掌握@Inherited注释的作用
			
		4.1 @Target注释：
			之前定义的Annotation，如果没有明确的说明可以在任意位置上使用；
			如果现在需要指定其使用范围的话，则必须使用@Target注释；	
		
			ElementType的保存范围：
				public static final ElementType ANNOTATION_TYPE
					只能用在注释声明上；
				public static final ElementType CONSTRUCTOR
					只能用在构造方法声明上；
				public static final ElementType FIELD
					只能用在字段声明（包括枚举常量）上；
				public static final ElementType LOCAL_VARIABLE
					只能用在局部变量声明上；
				public static final ElementType METHOD
					只能用在方法的声明上；
				public static final ElementType PACKAGE
					只能用在包的声明上；
				public static final ElementType PARAMETER
					只能用在参数的声明上；
				public static final ElementType TYPE
					只能用在类、接口、枚举类型上；
	
		4.2 @Documented注释：
			可以用在任何的Annotation上使用。所有的Annotation默认情况下都是使用@Documented进行注释的，
			而且在生成javadoc的时候可以通过@Documented设置一些说明信息。
			之后通过javadoc命令，生成java.doc文档
				javadoc -d 目录    文件名.java
	
		4.3 @Inherited注释：
			此注释表示一个Annotation是否可以被继承下来；
			定义一个父类，在父类上使用此Annotation；
			
java数据库编程：java.sql.*包中；
	1.JDBC概述：
		在实际开发中，可以直接使用JDBC进行各个数据库的连接操作，而且可以方便的向数据库中发送各种SQL命令。在JDBC中提供的是一套
		标准的接口，这样，各个支持JAVA的数据库生产商只要按照此接口提供相应的实现，则就都可以使用JDBC进行操作。
		
		JDBC驱动：
			JDBC-ODBC桥驱动；
				是sun公司提供的一个标准的jdbc操作，直接利用微软的ODBC进行数据库的连接操作，操作性能较低，不推荐使用；
			JDBC本地驱动；
				直接使用各个数据库生产商提供的JDBC驱动程序，但是因为其只能应用在特定的数据库上，会丧失掉程序的可移植性，但是这样的操作性能较高；
				JDBC本身提供的是一组类和接口，各个数据库生产商要实现这些接口，所有这些驱动程序时需要单独配置的，往往是以一组jar包(zip包)的形式出现的，
				如果要使用的话，则肯定要配置classpath；在开发中大部分情况都是使用一种数据库的开发，所有一般使用此种模式是最多的。
			JDBC网络驱动；
				这种驱动程序将JDBC转换为与DBMS无关的网络协议，之后这种网络协议又被某个服务器转换为一种DBMS协议。这种网络服务器中间件能够将它的纯java客户机
				连接到多种不同的数据库上。所用的具体协议取决于提供者。通常，这是最为灵活的JDBC驱动程序。
			本地协议纯JDBC驱动；
				这种类型的驱动程序将JDBC调用直接转换为DBMS所使用的网络协议。这将允许从客户机机器上直接调用DBMS服务器，时Internet访问的一个很实用的解决方法。
	
		JDBC的主要操作类和接口：
			java.sql.DriverManager
				用于管理JDBC驱动程序；是一个最常用的类，使用此类可以连接一个数据库；
			java.sql.Connection
				用于建立与特定数据库的连接，一个连接就是一个会话，建立连接后便可以执行SQL语句和获得检索结果；
			java.sql.Statement
				一个Statement对象用于执行静态SQL语句，并获得语句执行后产生的结果；
			java.sql.PreparedStatement
				创建一个可以编译的SQL语句对象，该对象可以被多次运行，以提高执行的效率，该接口时Statement的子接口；
			java.sql.ResultSet
				用于创建表示SQL语句检索结果的结果集，用户通过结果集完成对数据库的访问；
			java.sql.Date
				该类是标准java.util。Date的一个子集，用于表示与SQL DATE相同的日期类型，该日期不包括时间；
			java.sql.Timestamp
				标准java.util.Date类的扩展，用于表示SQL时间戳，并增加了一个能表示纳秒的时间域；
			java.sql.CallableStatement
				用于执行SQL存储过程；
			java.sql.DatabaseMetaData
				与java.sql.ResultSetMetaData一同用于访问数据库的元信息；
			java.sql.Driver
				定义一个数据库驱动程序的接口；
			java.sql.DataTruncation
				在JDBC遇到数据截断的异常时，报告一个警告（读数据时）或产生一个异常（写数据时）；
			java.sql.DriverPropertyInfo
				高级程序设计人员通过DriverPropertyInfo与Driver进行交流，可使用getDriverPropertyInfo获取或提供驱动程序的信息；
			java.sql.Time
				该类是标准java.util.Date的一个子集，用于表示时、分、秒；
			java.sql.SQLException
				对数据库访问时产生的错误的描述信息；
			java.sql.SQLWarning
				对数据库访问时产生的警告的描述信息；
			java.sql.Types
				定义了表示SQL类型的常量；
	
	2.MySql数据库：
		
	3.JDBC操作步骤及数据库连接操作：
		掌握JDBC的操作步骤；
		掌握数据库驱动程序的配置方法；
		可以使用JDBC进行数据库连接；
	
		3.1 数据库JDBC操作步骤：
			1.加载数据库驱动程序；
			2.连接数据库；
			3.使用语句进行数据库操作；
			4.关闭数据库连接；
		
		3.2配置数据库的驱动程序：
			环境变量--新建--classpath中加入驱动程序所在的路径和驱动程序名称；
		 
		3.3加载驱动程序：
			通过Class.forName()语句可以加载一个驱动程序；
			Class实例化需要一个完整的包.类名称，此“包.类”名称的路径就应该是驱动程序的名称；
	
		3.4连接和关闭数据库：
			数据库驱动程序可以正常加载的话，下面就可以连接数据库了，使用DriverManager类进行连接操作，DriverManager类中的常用方法如下：
				public static Connection getConnection(String url)throws SQLException
					通过连接地址连接数据库；
				public static Connection getConnection(String url,String user,String password)throws SQLException
					通过连接地址连接数据库，同时输入用户名和密码；
			
			在driverManager中，提供的主要操作就是得到一个数据库的连接，getConnection()方法就是取得连接对象，此方法返回的类型时Connection对象，
			不管使用哪种连接方式，都必须提供一个数据库的连接地址，如果在连接数据库的时候需要用户名和密码，则还需要将用户名和密码设置上。
			*连接格式如下：
				jdbc:mysql://ipAddress:port/databaseName
			数据库操作完成后，必须关闭；
			
			Connection接口的常用方法：
				Statement createStatement()throws SQLException
					创建一个Statement对象；
				Statement createStatement(int resultSetType,int resultSetConcurrency)throws SQLException
					创建一个Statement对象，该对象将生成具有给定类型和并发性的ResultSet对象；
				PreparedStatement prepareStatement(String sql)throws SQLException
					创建一个PreparedStatement类型的对象；
				PreparedStatement prepareStatement(String sql,int resultSetType,int resultSetConcurrency)throws SQLException
					创建一个PreparedStatement对象，该对象生成具有给定类型和并发性的ResultSet对象；
				CallableStatement prepareCall(String sql)throws SQLException
					创建一个CallableStatement对象，此对象专门用于调用数据库的存储过程；
				CallableStatement prepareCall(String sql,int resultSetType,int resultSetConcurrency)throws SQLException
					创建一个CallableStatement对象，该对象将生成具有给定类型和并发性的ResultSet对象；
				DatabaseMetaData getMetaData()throws SQLException
					得到数据库的元数据；
				void setAutoCommit(boolean autoCommit)throws SQLException
					设置数据库的自动提交，与事物有关；
				boolean getAutoCommit()throws SQLException
					判断数据库是否可以自动提交，与事物有关；
				Savepoint setSavepoint()throws SQLException
					设置数据库的恢复点，与事物有关；
				Savepoint setSavepoint(String name)throws SQLException
					为数据库的恢复点指定一个名字，与事物有关；
				void rollback()throws SQLException
					数据库操作回滚，与事物有关；
				void rollback(Savepoint savepoint)throws SQLException
					数据库回滚到指定的保存点，与事物有关；
				void commit()throws SQLException
					提交操作，与事物有关；
				boolean isClosed()throws Exception
					判断连接是否已关闭；
				void close()throws SQLException
					关闭数据库；
				DatabaseMetaData getMetaData()throws SQLException
					得到数据库的元数据对象；
	
		3.5执行数据库更新操作：
			本章目标：
				可以使用Connection对象取得Statement实例；
				可以使用Statement进行数据增加、修改、删除操作；
			
			Statement接口：
				数据库可以连接之后，下面就可以进行数据库的具体操作了，如果要想对数据库进行操作，则肯定要使用Statement接口完成，此接口可以使用Connection接口中的提供的createStatement()方法实例化；
				此接口中的常用方法：
					int executeUpdate(String sql)throws SQLException
						执行数据库更新的SQL语句，例如：INSERT UPDATE DELETE等语句，返回更新的记录数；
					ResultSet executeQuery(String sql)throws SQLException
						执行数据库查询操作，返回一个结果集对象；
					void addBatch(String sql)throws SQLException
						增加一个待执行的SQL语句；
					int[] executeBatch()throws SQLException
						批量执行SQL语句；
					void close()throws SQLException
						关闭Statement操作；
					boolean execute(String sql)throws SQLException
						执行SQL语句；
		
		3.6 ResultSet接口：
			掌握ResultSet接口的主要作用；
			使用ResultSet接口查询数据；
			
			将查询的数据显示出来；
			常用方法：
				boolean next()throws SQLException
					将指针移动到下一行；
				int getInt(int columnIndex)throws SQLException
					以整数形式按列的编号取得指定列的内容；
				int getInt(String columnName)throws SQLException
					以整数形式取得指定列的内容；
				float getFloat(int columnIndex)throws SQLException
					以浮点型的形式按列的编号取得指定列的内容；
				float getFloat(String columnName)throws SQLException
					以浮点数的形式取得指定列的内容；
				String getString(int columnIndex)throws SQLException
					以字符串的形式按列的编号取得指定列的内容；
				String getString(String columName)throws SQLException
					以字符串的形式取得指定列的内容；
				Date getDate(int columnIndex)throws SQLException
					以Date的形式按列的编号取得指定列的内容；
				Date getDate(String columnName)throws SQLException
					以Date的形式取得指定列的内容；
		
		3.7 PreparedStatement接口：插入时，先占位，之后在设置内容
			掌握PreparedStatement接口的工作原理；
			可以使用PreparedStatement进行数据库的更新及查询操作；
			
			PreparedStatement是Statement的子接口，属于预处理操作，与直接使用Statement不同的是，PreparedStatement在操作时，
			是现在数据表之中准备好一条SQL语句，但是此SQL语句的具体内容暂时不设置，而是之后再设置，以插入数据为例：使用PreparedStatement插入数据时，
			数据表中的指针首先指向最后一条数据之后，但是里面的内容是不知道的，而是等待用户分别设置；		
			常用方法：
				int executeUpdate()throws SQLException
					执行设置的预处理SQL语句；
				void setInt(int parameterIndex,int x)throws SQLException		
					指定要设置的索引编号，并设置整数内容；
				void setFloat(int parameterIndex,float x)throws SQLException
					指定要设置的索引编号，并设置浮点数内容；
				void setString(int parameterIndex,String x)throws SQLException
					指定要设置的索引编号，并设置字符串内容；
				void setDate(int parameterIndex,Date x)throws SQLException
					指定要设置的索引编号，并设置java.sql.Date类型的日期内容；
			
			通过Connection接口中的PreparedStatement prepareStatement(String sql)throws SQLException方法得到一个PreparedStatement的接口实例，
			之后再使用一系列的setXXX()方法设置内容，根据位置设置；
			如果执行更新语句的话，则会返回更新数据的记录数；
			
			*注意点：
				关于日期的输入问题：在正常情况下都使用java.util.Date表示日期，但是在PreparedStatement中如果要想使用日期必须使用java.sql.Date类型。		
				
				在开发中到底是使用PreparedStatement接口还是使用Statement接口呢？
					实际上开发应用中不使用Statement接口，因为其采用的是拼凑的SQL语句形式，那么这样一来就有可能造成SQL的注入漏洞；
					举例：最早的国内的大部分站点 ，只要输入“'”单引号已查询，就完蛋了。
			
	4.处理大数据对象：只能通过PreparedStatement操作完成
		create table userblob(
			id int AUTO_INCREMENT PRIMARY KEY,
			name VARCHAR(30) not null,
			photo LONGBLOB
		);
		
		create table user(
			id int AUTO_INCREMENT PRIMARY KEY,
			name varchar(30) not null,
			password varchar(32) not null,
			age int not null,
			sex varchar(4) default "man",
			birthday DATE
		);
		
		4.1  处理CLOB数据：专门保存海量文字的；
			了解大对象处理的基本原理；
			掌握CLOB数据的读写操作；
			可以使用Clob类方便的处理大文本数据；
			
			大对象处理主要指的是CLOB和BLOB两种类型的字段，在CLOB中可以存储海量文字，如：存储一部《三国演义》；在BLOB中可以存储二进制数据，如图片、电影等等；
			如果在程序中要想处理这样的大对象操作，则必须使用PreparedStatement完成，所有的内容要通过IO流的方式从大文本字段中保存和读取。
			
			写入大对象数据方法：
				void setAsciiStream(int parameterIndex,InputStream x,int length)throws SQLException
					将指定的输入流写入数据库的文本字段；
				void setBinaryStream(int parameterIndex,InputStream x,int length)throws SQLException	
					将二进制的输入流数据写入到二进制字段之中；
			
			读取大对象数据：
				InputStream getAsciiStream(int columnIndex)throws SQLException
					根据列的编号返回大对象的文本输入流；
				InputStream getAsciiStream(String columnName)throws SQLException
					根据列的名称返回大对象的文本输入流；
				Clob getClob(int i)throws SQLException
					根据列的编号返回Clob数据；
				Clob getClob(String cloName)throws SQLException
					根据列名称返回Clob数据；
				InputStream getBinaryStream(int columnIndex)throws SQLException
					根据列的编号，返回二进制数据；
				InputStream getBinaryStream(String columnName)throws SQLException
					根据列的名称，返回二进制数据；
				Blob getBlob(int i)throws SQLException		
					根据列的编号，返回Blob数据；
				Blob getBlob(String colName)throws SQLException
					根据列名称，返回Blob数据；
				
			CLOB表示大文本数据，在Mysql中提供了LONGTEXT表示大文本数据，此字段的最大保存数据量为4G；
			可以使用ResultSet中提供的getClob()方法，将全部的内容变为Clob对象的内容，直接使用Clob可以方便的取得大文本的数据，
			也可以对这些文本数据进行一些简单的操作，如截取指定长度的文本等。
				
		4.2  处理BLOB数据：专门保存二进制数据，包括（图片、音乐、电影等）
			掌握BLOB数据的读、写操作；
			可以使用BLOB类方便的处理二进制数据；
			
			BLOB表示大二进制数据，在Mysql中使用LONGBLOB声明，最高可以保存4G大小的内容；
			
			与大文本操作类似，在JDBC中也提供了专门的BLOB类型，用于表示二进制数据；
			常用方法：
				InputStream getBinaryStream()throws SQLException
					取得BLOB的输入流；
				byte[] getBytes(long pos,int length)throws SQLException
					以字节数组的形式返回Blob数据的内容；
				long length()throws SQLException
					取出数据的长度；
			
			但是从实际角度来看，把一个过大的文件存放在数据库中是不明智的，因为数据过大，往往采用的是映射路径的方式写入的。
		
	5. CallableStatement接口：很少用，了解即可；
		了解Mysql存储过程的建立；
		了解存储过程中参数传递的三种方式；
		了解CallableStatement调用存储过程的操作；
		
		CallableStatement主要是调用数据库中的存储过程，CallableStatement也是Statement接口的子接口；在使用CallableStatement的时候可以接收过程的返回值。
		常用方法：
			int getInt(int parameterIndex)throws SQLException
				根据编号取出过程的返回值；
			float getFloat(int parameterIndex)throws SQLException
				根据编号取出过程的返回值；
			void setInt(String paramenterName,int x)throws SQLException
				设置指定编号的内容；
			void setFloat(String parameterName,float x)throws SQLException
				设置指定编号的内容；
			void registerOutParaameter(int parameterIndex,int sqlType)throws SQLException
				设置返回值的类型，需要使用Types类；
			
		在JDBC中，如果要想设置过程的返回值类型，可以使用Types完成，在Types中定义了很多的常量，如果现在返回值类型为int，则使用：
			Types.INTEGER
		三种数据类型：	
			IN 类型：默认的设置，什么都不声明就表示IN类型，只是将内容传递进来；
			INOUT类型：表示把值传递到过程中，并且可以保留过程对此值的修改，引用；
			OUT类型：可以不用传递内容，过程中对此值的操作可以返回；	
			
	6.JDBC2.0操作：
		了解jdbc2。0提供的主要新特性；
		了解可滚动结果集的操作；
		了解结果集的增加、修改、删除操作；
		掌握批处理操作；
		
		在jdbc2。0，加强了结果集ResultSet的功能，可以直接使用ResultSet执行更新的操作，或者实现双向滚动；可以一次性执行多个语句；
		JDBC 2.0对ResultSet的支持：
			static final int TYPE_FORWARD_ONLY
				表示指针只能向前移动的ResultSet，是默认值；
			static final int TYPE_SCROLL_SENSITIVE
				表示ResultSet可以滚动，可以更新内容；
			static fianl int TYPE_SCROLL_INSENSITIVE
				表示ResultSet可以滚动，但不能更新内容；
			static final int CONCUR_READ_ONLY
				按只读的方式打开数据库；
			static final int CONCUR_UPDATABLE
				表示ResultSet可以更新；
			boolean absolute(int row)throws SQLException
				将结果集移动到指定行；
			void afterLast()throws SQLException
				将结果集移动到末尾之后；
			void beforeFirst()throws SQLException
				将结果集移动到首航之前；
			boolean first()throws SQLException
				将结果集移动到第一行；
			boolean last()throws SQLException
				将结果集移动到最后一行；
			boolean previous()throws SQLException
				将结果集向上移动；
			void updateString(int columnIndex,String x)throws SQLException
				指定更新列的内容，此方法被重载多次，支持各种数据类型；
			void updateString(String columnName,String x)throws SQLException
				指定更新列的内容，此方法被重载多次，支持各种数据类型；
			void moveToInsertRow()throws SQLException
				将指针移动到插入行；插入数据；
			void updateRow()throws SQLException
				更新行数据信息；
			void cancelRowUpdates()throws SQLException
				取消更新数据，在updateRow()调用之前有效；
			void insertRow()throws SQLException
				插入行数据；
			void deleteRow()throws SQLException
				删除行数据；
				
		如果想要创建可滚动的结果集，则在创建PreparedStatement（Statement）的时候必须指定了创建的类型。
		开发中一般不使用可滚动的结果集。
		如果想要使用ResultSet插入数据，则在创建数据库操作的时候就必须选择好允许更新。插入数据的方法：

		批处理：
			就是指一次性向数据库中执行多条语句，一次提交。
			加入语句：
				void addBatch()throws SQLException
			执行语句：
				int[] executeBatch()throws SQLException
					
		小结：
			了解jdbc2.0中结果集的功能提升：可滚动、可插入、可修改、可删除；
			如果要想创建灵活的结果集，则在创建数据库操作的时候就必须指定类型；
			批处理可以一次性提交多条数据到数据库表中；	
			
	7.事务处理：
		所谓事务处理就是所有的操作要么一起成功，要么一起失败，事物本身具有原子性（Atomicity）、一致性（Consistency）、隔离性或独立性（Lsolation）、持久性（Durabilily）四个特性，以上的四个特性，也被称为ACID特性。
			原子性：
				是事务最小的单元，是不可再分割的单元，相当于一个个小的数据库操作，这些操作必须同时完成，如果有一个失败了，则一切的操作全部失败。
			一致性：
				指的是在数据库操作的前后是完全一致的，保证数据的有效性，如果事务正常操作则系统维持有效性，如果事务出现了错误，则回到最原始状态。也要维持其有效性，这样保证事务开始时和结束时系统处于一致状态。
			隔离性：
				多个事务可以同时进行且彼此之间无法访问，只有当事务完成最终操作的时候，才可以看见结果。
			持久性：
				当一个系统崩溃时，一个事务依然可以坚持提交，当一个事务完成后，操作的结果保存到磁盘中，永远不会回滚。		
		Mysql对事务的支持：
			SET AUTOCOMMIT = 0
				取消掉自动提交处理，开启事务处理；
			SET AUTOCOMMIT = 1
				打开自动提交处理，关闭事务处理；
			START TRANSACTION
				启动事务；
			BEGIN
				启动事务，相当于执行START TRANSACTION；
			COMMIT
				提交事务；
			ROLLBACK
				回滚全部操作；
			SAVEPOINT事务保存点名称
				设置事务保存点；
			ROLLBACK TO SAVEPOINT
				回滚操作到保存点；
			
		如果想要操作事务的话，则必须按照以下的步骤完成：
			1.取消自动提交：每次执行数据库更新的时候实际上发出SQL命令之后就已经提交上去；
			2.开始事务；
			3.进行一系列的操作；
			4.如果操作全部合格，则提交事务；
			5.如果发现一个地方有问题，则可以进行回滚；
			6.或者设置一个SAVEPOINT保存事务的提交点；
			
		JDBC事务操作步骤：
			在jdbc中，如果要想进行事务处理，也需要安装指定的步骤完成：
				1.取消掉Connection中设置的自动提交方式；
					conn.setAutoCommit(false);
				2.如果批处理操作成功，则执行提交事务：
					conn.commit();
				3.如果操作失败，则肯定会引发异常，在异常处理中让事务回滚：
					conn.rollback();
				4.如果需要，可以设置Savepoint：
					Savepoint sp = conn.setSavepoint();
			在开发汇中，这是标准的事务处理操作；	
			正常情况下，可以通过SAVEPOINT保存事务的操作点，因为默认情况下所有的回滚，就是将全部的操作取消掉，而通过Savepoint设置回滚的位置；
		
	8.使用元数据分析数据库；
		了解DatabaseMetaData；
		了解ResultSetMetaData；
		
		DatabaseMetaData：
			使用元数据可以分析数据库的基本信息，包括数据库的名称、版本以及得到表的信息；
			常用方法：
				String getDatabaseProductName()throws SQLException
					得到数据库的名称；
				int getDriverMajorVersion()
					得到数据库的主版本号；
				int getDriverMinorVersion()
					得到数据库的次版本号；
				ResultSet getPrimaryKeys(String catalog,String schema,String table)throws SQLException
					得到表的主键信息，每一个主键都有以下的描述：
						TABLE_CAT String =>表类别（可为null）；
						TABLE_SCHEM String =>表模式（可为null）；
						TABLE_NAME String =>表名称；
						COLUMN_NAME String =>列名称；
						KEY_SEQ short =>主键中的序列号；
						PK_NAME String =>主键的名称（可为null）；
		ResultSetMetaData：
			使用ResultSetMetaData可以获取关于ResultSet对象中列的类型和属性信息的对象，ResultSetMetaData存储了ResultSet的MetaData，可以通过以下的方法取得ResultSet的信息。
			常用方法：
				int getColumnCount()throws SQLException
					返回一个查询结果中的列数；
				boolean AutoIncrement(int column)throws SQLException
					判断指定列是否是自动编号；
				String getColumnName(int column)throws SQLException
					返回列的名称；		
		以上的两个操作在一般的数据的开发底层上比较常用，实际上也就是类似于反射的操作机制，取得一些基本的信息。在正常开发中基本上是不会用的。
	
图像界面：
	了解AWT作用：
		专门创建桌面程序的；
	了解Swing与AWT的关系；
		Jxx就表示Swing的操作；
		Swing继承自AWT；
		AWT和Swing的关系，可以发现Swing中还是大量使用了AWT的开发包，在现在的开发中肯定不会再去使用AWT，连Swing基本上都不怎么使用了。
		
	在整个AWT包中提供的所有工具类，主要分为以下三种：
		组件：Component
			在整个AWT包中，所有的组件类（例如：按钮、文本框等）都是从Component和MenuComponent扩展而来的，这些类会继承这两个类的公共操作。
		容器：Container
			所有的AWT组件都应该放到容器之中。在容器之中，所有的组件都可以设置在容器中的位置、大小等，所有的容器都是Commponent的子类，在AWT中包含以下几种容器。
				Window：
					Frame：
					Dialog：
				Panel：
				ScrollPane：
		布局管理器：LayoutManager	
			使用布局管理器可以使容器中的组件按照指定的位置进行摆放，另外的一个好处是，即使容器改变了大小，布局管理器也可以准确的把组件放到指定的位置，这样就可以有效的保证版面不会混乱。
			在AWT中所有的布局管理器都是LayoutManager的子类。	
		 
	1.基本容器JFrame：		
		如果要使用Swing创建一个窗口，则直接使用JFrame类即可，此类事Component的子类；
		Dimension类：
			在JFrame中设置窗体的大小，也可以使用Dimension类完成，此类封装的就是组件的显示宽度和高度，此类的常用操作方法如下：
				public Dimension()
					创建一个Dimension实例；
				public void setSize(double width,double height)
					设置显示的宽和高；
				public void setSize(int width,int height)
					设置显示的宽和高；
				public double getWidth()
					返回组件的宽；
				public double getHeight()
					返回组件的高；
		
		Point类：
			组件的显示位置也可以使用Point类指定，此类封装的是显示位置的X、Y坐标，此类的常用方法如下：
				public Point()
					构造，在坐标原点创建对象；
				public Point(int x,int y)
					在指定的坐标点创建对象；
				public void setLocation(double x,double y)
					设置X、Y坐标；
				public void setLocation(int x,int y)
					设置X、Y坐标；
				public void move(int x,int y)
					将此组件移动到指定坐标位置，此方法与setLocation(int x,int y)相同；
				public void translate(int dx,int dy)
					平移（x,y）位置的点，沿x轴平移dx，沿y轴平移dy，移动后得到点（x + dx, y + dy）；
					
		小结：
			1.所有的组件都要向容器之中增加；
			2.JFrame本身的窗体是不具备关闭功能的，如果要想关闭的话，则需要编写对应的时间监听操作；
	
	2.JLable标签组件：
		表示一个标签，就是只用于显示信息的一个组件；		
		2.1更改JLabel的文字样式：
			如果现在要想更改使用的字体，则可以直接使用Component类中定义的以下方法：
				public void setFont(Font f)
					在设置的时候使用了java.awt.Font类来表示字体，Font类的常用操作方法及常量如下：
						public static final int BOLD
							文字显示为粗体；
						public static final int ITALIC
							文字显示风格为斜体；
						public static final int PLAIN
							文字显示风格为普通样式；
						public Font(String name,int style,int size)
							实例化对象，指定显示风格及大小；
						public String getFontName()
							得到字体的名称；
			
			可以通过GraphicsEnvironment类中的静态方法getLocalGraphicsEnvironment()方法得到本机所有的可用字体；
			
		2.2在JLable中也可以设置显示的图片：
			如果要想设置显示的图片，可以使用IO流方式进行图片的读取；			
			但是使用IO流读取太麻烦了；可以使用Icon类的另一个构造方法，直接传入图片地址；
				Icon icon = new Icon(picPath);						
							
	3.JButton组件：
		表示一个普通的按钮，直接使用此类就可以直接在窗体中增加一个按钮；
				
	4.布局管理器：Layout
		使用布局管理器可以管理组件的显示位置，每当需要重新调整屏幕大小或重新绘制屏幕上任意一项时，都要用到布局管理器；
		在Swing中使用的所有布局管理器都实现LayoutManager接口，在Swing中主要使用以下五种常见的布局管理器：
			FlowLayout
				流式布局管理器；
			BorderLayout
				将一个窗体的版面划分为东西南北中五个区域，可以直接将需要的组件放到这五个区域中即可；
			GridLayout
				是以表格的形式进行管理的，在使用此布局管理器的时候必须设置显示的行数和列数；
			GardLayout
				将一组组件彼此重叠的进行布局，就像一张张卡片一样，这样每次只会展现一个界面；
			绝对定位；				
				通过设置绝对坐标的方式完成，在Component中提供了setBounds()方法，可以定位一个组件的坐标，使用X、Y的坐标表示方式，此方法定义如下：
					public void setBounds(int x,int y,int width,int height);
	
	5.JPanel容器：
		JPanel也是一种经常用到的容器之一，可以使用JPanel完成各种复杂的界面显示。
		在JPanel中可以加入任意的组件，之后直接将JPanel容器加入到JFrame容器中即可显示。		
		
	6.JSplitPane容器：
		JSplitPane主要功能是分隔面板，可以将一个窗体分隔为两个子窗体，可以是水平排列也可以是垂直排列；			
	
	7.JTabbedPane：
		是在一个面板上设置多个选项卡供用户选择；
		
	8.JScollPane：
		在Swing中JScrollPane的主要功能就是为显示的内容加入水平滚动条。
		JScollPane主要由JViewport和JScrollBar两部分组成，前者主要是显示一个矩形的区域让用户浏览，而后者主要是形成水平或垂直的滚动条；	
		
		
		
		
		
		
		
		
		
		。。。。。。。。。	
			

JAVA网络编程：
	1.IP（Internet Protocol）与InetAddress：
		InetAddress类的常用方法：
			public static InetAddress getByName(String host)throws UnknownHostException
				通过主机名称得到InetAddress对象；
			public static InetAddress getLocalHost()throws UnknownHostException
				通过本机得到InetAddress对象；
			public String getHostName()
				得到IP地址；
			public boolean isReachable(int timeout)throws IOException
				判断地址是否可达，同时指定超时时间；
	
	2.URL与URLConnection：
		URL（Uniform Resource Locator）统一资源定位符，可以直接使用此类找到互联网上的资源（如：一个网页）；	
		
		URLConnection：
			是封装远程网络资源一般方法的类，通过它可以建立与远程服务器的连接，检查远程资源的一些属性；
			常用方法：
				public int getContentLength()
					取得内容的长度；
				public String getContentType()
					取得内容的类型；
				public InputStream getInputStream()throws IOException
					取得连接的输入流；	
	
	3.URLEncoder与URLDecoder类：（编码和解码）
		常用方法：
			public static String encode(String s,String enc)throws UnsupportedEncodingException
				使用指定的编码机制将字符串转换为application/x-www-form-urlencoded格式；
			public static String decode(String s,String enc)throws UnsupportedEncodingException
				使用指定的编码机制对application/x-www-form-urlencoded字符串解码；

		一般在进行网络程序开发时，传递中文的时候往往会需要进行编码和解码操作；

	4.TCP程序设计：
		在java中使用Socket（即套接字）完成TCP程序的开发，使用此类可以方便的建立可靠的、双向的、持续的、点对点的通讯连接；
		在Socket的程序开发中，服务器端使用ServerSocket等待客户端的连接，对于java的网络程序来讲，每一个客户端都使用一个Socket对象表示；

		在java的网络程序中，客户端只要符合连接的通讯协议，那么服务器端都可以进行接收；
		ServerSocket类主要用在服务器端程序的开发上，用于接收客户端的连接请求。
		常用方法：
			public ServerSocket(int port)throws IOException
				创建ServerSocket实例，并指定监听端口；
			public Socket accept()throws IOException
				等待客户端连接，此方法连接之前一直阻塞；
			public InetAddress getInetAddress()
				返回服务器的IP地址；
			public boolean isClosed()
				返回ServerSocket的关闭状态；
			public void close()throws IOException
				关闭ServerSocket；

		Accept()每次都会返回一个Socket对象；
		Socket：在服务器端每次运行时都要使用accept()方法等待客户端连接，此方法执行之后服务端将进入阻塞状态，直到客户端连接之后程序才可以向下继续执行，此方法的返回值类型是Socket，每一个Socket都表示一个客户端对象。
		常用方法：
			public Socket(String host,int port)throws UnknownHostException,IOException
				构造Socket对象，同时指定要连接服务器的主机名称及连接端口；
			public InputStream getInputStream()throws IOException
				返回此套接字的输入流；
			public OutputStream getOutputStream()throws IOExcetpion
				返回此套接字的输出流；
			public void close()throws IOException
				关闭此Socket；
			public boolean isClosed()
				判断此套接字是否被关闭；
			
		*通过Socket、IO、Thread类在一起，可以共同完成服务器端的代码开发；

	5.UDP程序设计：
		为了减少网络开销，在网络中又提供了另外一种传输协议--UDP，不可靠连接，在各个聊天工具中被广泛使用；
		在UDP开发中使用DatagramPacket包装一条要发送的信息，之后使用DatagramSocket用于完成信息的发送操作；
		UDP中主要使用的是数据报协议；是包含真实的要发送的信息，称为数据报；
		DatagramPacket常用方法：
			public DatagramPacket(byte[] buf,int length)
				构造，实例化DatagramPacket对象时，指定接收数据长度；
			public DatagramPacket(byte[] buf,int length,InetAddress address,int port)
				构造，实例化DatagramPacket对象时，指定发送的数据、数据的长度、目标地址及端口；
			public byte[] getData()
				返回接收的数据；
			public int getLength()
				返回要发送或接收数据的长度；
		
		所有的数据报使用DatagramSocket发送；常用方法：
			public DatagramSocket(int port)throws SocketException
				创建DatagramPacket对象，并指定监听端口；
			public void send(DatagramPacket p)throws IOException
				发送数据报；
			public void receive(DatagramPacket p)throws IOException
				接收数据报；		