java类集：
	类集实际上就是一个动态的对象数组，与一般的对象数组不同，类集中的对象内容可以任意扩充。
	类集的特征：
		1.这种框架是高性能的；
		2.框架必须允许不同类型的类集以相同的方式和高度互操作方式工作；
		3.类集必须是容易扩展和修改的。
	对象数组中包含一组对象，但是对象数组使用的时候存在一个长度的限制，那么类集是专门解决这种限制的，使用类集可以方便的向数组中增加任意多个数据。
	类集框架主要接口：
		Collection：存放对象
			是存放一组单值的最大接口，所谓的单值是指集合中的每个元素都是一个对象。一般很少会直接使用此接口直接操作；
		List：可重复
			是Collection接口的子接口，也是最常用的接口，此接口对Collection接口进行了大量的扩充，里面的内容是允许重复的；
		Set：不可重复
			是Collection接口的子接口，没有对Collection接口进行扩充，里面不允许存放重复内容；	
		Map：成对存放
			Map是存放一对值的最大接口，即，接口中的每一个元素都是一对，以key->value的形式保存。
		Iterator：
			集合的输出接口，用于输出集合中的内容，只能进行从前到后的单向输出；
		ListIterator：
			是Iterator的子接口，可以进行双向输出；
		Enumeration：
			是最早的输出接口，用于输出指定集合中的内容；
		SortedSet：
			单值的排序接口，实现此接口的集合类，里面的内容是可以排序的，使用比较器排序；
		SortedMap：
			存放一对值的排序接口，实现此接口的集合类，里面的内容按钮key排序，使用比较器排序；
		Queue：
			队列接口，此接口的子类可以实现对象操作；
		Map.Entry：
			Map.Entry的内部接口，每个Map.Entry对象都保存着一对key->value的内容，每个Map接口中都保存多个Map.Entry接口实例。
	
	以上接口必须全部掌握。
	
	1.Collection接口：java.util包中
		是保存单值集合的最大父接口；
		定义格式：		 
			public interface Collection<E> extends Iterable<E>
		常用方法：
			public boolean add(E o)
				向集合中插入对象；
			public boolean addAll(Collection<? extends E> c)
				将一个集合的内容插入进来；
			public void clear()
				清除此集合中所有元素；
			public boolean contains(Object o)
				判断某一个对象是否在集合中存在；
			public boolean containsAll(Collection<?> c)
				判断一组对象是否在集合中存在；
			public boolean equals(Object o)
				对象比较；
			public int hashCode()
				哈希码；
			public boolean isEmpty()
				判断集合是否为空；
			public Iterator<E> iterator()
				为Iterator接口实例化；
			public boolean remove(Object o)
				删除指定对象；
			public boolean removeAll(Collection<?> c)
				删除一组对象；
			public boolean retainAll(Collection<?> c)
				保存指定内容；
			public int size()
				求出集合的大小；
			public Object[] toArray()
				将一个集合变为对象数组；
			public <T> T[] toArray(T[] a) 
				指定好返回的对象数组类型；
		
		*Collection接口的使用注意：
			在一般开发中，往往很少直接使用Collection接口进行开发，因为表示的操作意义不明确。
			而基本上都是使用其子接口，主要有：List、Set、Queue、SortedSet。
				List接口：可以存放重复的内容；
				Set接口：不能存放重复的内容，所有的重复内容是靠hashCode()和equals()两个方法区分的；
				Queue接口：队列接口；
				SortedSet接口：可以对集合中的数据进行排序；
		
	2.List接口：可重复
		本章目标：
			1.掌握List接口与Collection接口的关系；
			2.掌握List接口的常用子类：ArrayList、Vector；
			3.掌握ArrayList与Vector类的区别；
		
		List接口是Collection接口的子接口，List接口中可以存放任意的数据。而且在List接口中内容是允许重复的。
		定义格式：
			public interface List<E> extends Collection<E>	
		常用（扩展）方法：
			public void add(int index, E element)
				在指定位置增加元素；
			public boolaen addAll(int index, Collection<? extends E> c)
				在指定位置增加一组元素；
			E get(int index)
				返回指定位置的元素；
			public int indexOf(Object o)
				查找指定元素的位置；
			public int lastIndexOf(Object o)
				从后向前查找指定元素的位置；
			public ListIterator<E> listIterator()
				为ListIterator接口实例化；
			public E remove(int index)
				按指定的位置删除元素；
			public List<E> subList(int fromIndex, int toIndex)
				取出集合中的子集合；截取部分集合：
			public E set(int index, E element)
				替换指定位置的元素；
		
		2.1 List接口的常用子类--ArrayList：是List接口中最常用的子类；
			ArrayList是List接口的子类，可以直接通过对象的多态性，为List接口实例化；
			此类的定义格式如下：
				public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, Serializable
				
			AbstractList类的定义如下：
				public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E>
				
		2.2 Vector类：是List接口的子类：
			考虑到大多数人已经习惯了Vector类，Java设计者就让Vector类实现了已List接口，这才将其保存下来。但是因为其实List接口的子类，所有Vector类的使用与之前的并没有太大的区别；
			Vector类的定义如下：
				public class Vector<E> extends AbstractList<E> implements List<E> RandomAccess, Cloneable, Serializable
				
		***子类的差异：ArrayList与Vector的区别：
			1.推出时间：
				ArrayList：JDK1.2之后推出的，属于新的操作类；
				Vector：JDK1.0时推出的，属于旧的操作类；
			2.性能：
				ArrayList：采用异步处理的方式；
				Vector：采用同步的方式，性能较低；
			3.线程安全：
				ArrayList：属于非线程安全的操作类；
				Vector：属于线程安全的操作类；
			4.输出：
				ArrayList：只能使用Iterator、foreach输出；
				Vector：可以使用Iterator、foreach、Enumeration输出；
		
	3.Queue接口与LinkedList子类：
		队列操作（对头永远是新增的内容，队尾永远是先出的内容）
		3.1 LinkedList表示的是一个链表的操作类，此类的定义如下：
 				public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Queue<E>, Clineable, Serializable
 			LinkedList子类的常用方法：
				public void addFirst(E o)
					在链表开头增加元素；
				public vlid addLast(E o)
					在链表结尾增加元素；
				public boolean offer(E o)
					将指定元素增加到链表的结尾；
				public E removeFirst()
					删除链表的第一个元素；
				public E removeLast()
					删除链表的最后一个元素；
 			LinkedList本身大量扩充了Queue接口和List接口的操作，所有在使用时最好直接使用LinkedList类完成操作。
 		3.2 Queue接口是Collection的子接口，此接口定义如下：
 				public interface Queue<E> extends Collection<E>	
			Queue接口的常用方法：
				public E element()
					找到链表的表头；
				public boolean offer(E o)
					将指定元素增加到链表的结尾；
				public E peek()
					找到但并不删除链表的头；
				public E poll()
					找到并删除链表的头；
				public E remove()
					检索并移除表头；
		
	4.Set接口：不可重复
		掌握：
			treeSet的排序原理；
			Set接口中重复元素的定义；
	
		Set接口也是Collection接口的子接口，但是与Collection或List接口不同的是，Set接口中不能加入重复的元素；
		Set接口的定义：
			public interface Set<E> extends Collection<E>
		Set接口的主要方法与Collection是一致的；
		Set接口的实例无法像List接口那样进行双向输出；因为没有提供get()方法；
		Set接口的常用子类：
			散列存放：HashSet
			有序存放：TreeSet
		
		 如果想要取消掉重复元素，则需要Object类中的两个方法帮助：
		 	*1.hashCode()：表示一个唯一的编码，一般通过计算表示；
		 	*2.equals()：进行对象的比较操作；
		 	
		 小结：
		 	Set接口依靠hashCode()和equals()完成重复元素的判断，关于这一点在日后的Map接口中也有体现；
		 	TreeSet依靠Compatable接口完成排序操作。
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
			