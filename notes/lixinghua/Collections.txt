java类集：
	类集实际上就是一个动态的对象数组，与一般的对象数组不同，类集中的对象内容可以任意扩充。
	类集的特征：
		1.这种框架是高性能的；
		2.框架必须允许不同类型的类集以相同的方式和高度互操作方式工作；
		3.类集必须是容易扩展和修改的。
	对象数组中包含一组对象，但是对象数组使用的时候存在一个长度的限制，那么类集是专门解决这种限制的，使用类集可以方便的向数组中增加任意多个数据。
	类集框架主要接口：
		Collection：存放对象
			是存放一组单值的最大接口，所谓的单值是指集合中的每个元素都是一个对象。一般很少会直接使用此接口直接操作；
		List：可重复
			是Collection接口的子接口，也是最常用的接口，此接口对Collection接口进行了大量的扩充，里面的内容是允许重复的；
		Set：不可重复
			是Collection接口的子接口，没有对Collection接口进行扩充，里面不允许存放重复内容；	
		Map：成对存放
			Map是存放一对值的最大接口，即，接口中的每一个元素都是一对，以key->value的形式保存。
		Iterator：
			集合的输出接口，用于输出集合中的内容，只能进行从前到后的单向输出；
		ListIterator：
			是Iterator的子接口，可以进行双向输出；
		Enumeration：
			是最早的输出接口，用于输出指定集合中的内容；
		SortedSet：
			单值的排序接口，实现此接口的集合类，里面的内容是可以排序的，使用比较器排序；
		SortedMap：
			存放一对值的排序接口，实现此接口的集合类，里面的内容按钮key排序，使用比较器排序；
		Queue：
			队列接口，此接口的子类可以实现对象操作；
		Map.Entry：
			Map.Entry的内部接口，每个Map.Entry对象都保存着一对key->value的内容，每个Map接口中都保存多个Map.Entry接口实例。
	
	以上接口必须全部掌握。
	
	1.Collection接口：java.util包中
		是保存单值集合的最大父接口；
		定义格式：		 
			public interface Collection<E> extends Iterable<E>
		常用方法：
			public boolean add(E o)
				向集合中插入对象；
			public boolean addAll(Collection<? extends E> c)
				将一个集合的内容插入进来；
			public void clear()
				清除此集合中所有元素；
			public boolean contains(Object o)
				判断某一个对象是否在集合中存在；
			public boolean containsAll(Collection<?> c)
				判断一组对象是否在集合中存在；
			public boolean equals(Object o)
				对象比较；
			public int hashCode()
				哈希码；
			public boolean isEmpty()
				判断集合是否为空；
			public Iterator<E> iterator()
				为Iterator接口实例化；
			public boolean remove(Object o)
				删除指定对象；
			public boolean removeAll(Collection<?> c)
				删除一组对象；
			public boolean retainAll(Collection<?> c)
				保存指定内容；
			public int size()
				求出集合的大小；
			public Object[] toArray()
				将一个集合变为对象数组；
			public <T> T[] toArray(T[] a) 
				指定好返回的对象数组类型；
		
		*Collection接口的使用注意：
			在一般开发中，往往很少直接使用Collection接口进行开发，因为表示的操作意义不明确。
			而基本上都是使用其子接口，主要有：List、Set、Queue、SortedSet。
				List接口：可以存放重复的内容；
				Set接口：不能存放重复的内容，所有的重复内容是靠hashCode()和equals()两个方法区分的；
				Queue接口：队列接口；
				SortedSet接口：可以对集合中的数据进行排序；
		
	2.List接口：可重复
		本章目标：
			1.掌握List接口与Collection接口的关系；
			2.掌握List接口的常用子类：ArrayList、Vector；
			3.掌握ArrayList与Vector类的区别；
		
		List接口是Collection接口的子接口，List接口中可以存放任意的数据。而且在List接口中内容是允许重复的。
		定义格式：
			public interface List<E> extends Collection<E>	
		常用（扩展）方法：
			public void add(int index, E element)
				在指定位置增加元素；
			public boolaen addAll(int index, Collection<? extends E> c)
				在指定位置增加一组元素；
			E get(int index)
				返回指定位置的元素；
			public int indexOf(Object o)
				查找指定元素的位置；
			public int lastIndexOf(Object o)
				从后向前查找指定元素的位置；
			public ListIterator<E> listIterator()
				为ListIterator接口实例化；
			public E remove(int index)
				按指定的位置删除元素；
			public List<E> subList(int fromIndex, int toIndex)
				取出集合中的子集合；截取部分集合：
			public E set(int index, E element)
				替换指定位置的元素；
		
		2.1 List接口的常用子类--ArrayList：是List接口中最常用的子类；
			ArrayList是List接口的子类，可以直接通过对象的多态性，为List接口实例化；
			此类的定义格式如下：
				public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, Serializable
				
			AbstractList类的定义如下：
				public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E>
				
		2.2 Vector类：是List接口的子类：
			考虑到大多数人已经习惯了Vector类，Java设计者就让Vector类实现了已List接口，这才将其保存下来。但是因为其实List接口的子类，所有Vector类的使用与之前的并没有太大的区别；
			Vector类的定义如下：
				public class Vector<E> extends AbstractList<E> implements List<E> RandomAccess, Cloneable, Serializable
				
		***子类的差异：ArrayList与Vector的区别：
			1.推出时间：
				ArrayList：JDK1.2之后推出的，属于新的操作类；
				Vector：JDK1.0时推出的，属于旧的操作类；
			2.性能：
				ArrayList：采用异步处理的方式；
				Vector：采用同步的方式，性能较低；
			3.线程安全：
				ArrayList：属于非线程安全的操作类；
				Vector：属于线程安全的操作类；
			4.输出：
				ArrayList：只能使用Iterator、foreach输出；
				Vector：可以使用Iterator、foreach、Enumeration输出；
		
	3.Queue接口与LinkedList子类：
		队列操作（对头永远是新增的内容，队尾永远是先出的内容）
		3.1 LinkedList表示的是一个链表的操作类，此类的定义如下：
 				public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Queue<E>, Clineable, Serializable
 			LinkedList子类的常用方法：
				public void addFirst(E o)
					在链表开头增加元素；
				public vlid addLast(E o)
					在链表结尾增加元素；
				public boolean offer(E o)
					将指定元素增加到链表的结尾；
				public E removeFirst()
					删除链表的第一个元素；
				public E removeLast()
					删除链表的最后一个元素；
 			LinkedList本身大量扩充了Queue接口和List接口的操作，所有在使用时最好直接使用LinkedList类完成操作。
 		3.2 Queue接口是Collection的子接口，此接口定义如下：
 				public interface Queue<E> extends Collection<E>	
			Queue接口的常用方法：
				public E element()
					找到链表的表头；
				public boolean offer(E o)
					将指定元素增加到链表的结尾；
				public E peek()
					找到但并不删除链表的头；
				public E poll()
					找到并删除链表的头；
				public E remove()
					检索并移除表头；
		
	4.Set接口：不可重复
		掌握：
			treeSet的排序原理；
			Set接口中重复元素的定义；
	
		Set接口也是Collection接口的子接口，但是与Collection或List接口不同的是，Set接口中不能加入重复的元素；
		Set接口的定义：
			public interface Set<E> extends Collection<E>
		Set接口的主要方法与Collection是一致的；
		Set接口的实例无法像List接口那样进行双向输出；因为没有提供get()方法；
		Set接口的常用子类：
			散列存放：HashSet
			有序存放：TreeSet
		
		 如果想要取消掉重复元素，则需要Object类中的两个方法帮助：
		 	*1.hashCode()：表示一个唯一的编码，一般通过计算表示；
		 	*2.equals()：进行对象的比较操作；
		 	
		 小结：
		 	Set接口依靠hashCode()和equals()完成重复元素的判断，关于这一点在日后的Map接口中也有体现；
		 	TreeSet依靠Compatable接口完成排序操作。
		
	5.SortedSet接口：排序接口
		TreeSet实际上也是SortedSet接口的子类：所以此接口的所有类都是可以排序的。
		SortedSet接口的定义如下：
			public interface SortedSet<E> extends Set<E>
		SortedSet接口中定义的方法：
			public Comparator<? super E> comparator()
				返回与排序有关联的比较器；
			public E first()
				返回集合中的第一个元素；
			public SortedSet<E> headSet(E toElement)
				返回从开始到指定元素的集合；
			public E last()
				返回最后一个元素；
			public SortedSet<E> subSet(E fromElement,E toElement)
				返回指定对象间的元素；
			public SortedSet<E> tailSet(E fromElement)
				从指定元素到最后；
				
		只要看到了SortedSet开头的接口，就是可以排序的接口。（按照Comparable排序）
		
	*6.Iterator接口：集合输出接口（从前向后输出，属于单向的输出）
		在集合的输出操作中，支持以下几种方式：
			1.Iterator
			2.ListIterator
			3.foreach
			4.Enumeration
		Iter接口简介：
			1.集合输出的标准操作：
				在使用集合输出的时候必须形成以下的一个思路：只要是碰到了集合输出的操作，就一定使用Iterator接口，因为这是最标准的做法；
			2.Iterator接口的操作原理：
				Iterator是专门的迭代输出接口，所谓的迭代输出就是将元素一个个进行判断，判断其是否有内容，如果有内容则把内容取出。
		
		对于Iterator而言，因为其本身是一个接口，所有要想实例化则必须依靠Collection接口完成。
		常用方法：
			public boolean hasNext()
				正向判断是否有内容；
			public E next()
				取出内容；
			public void remove()
				删除当前元素；
		
		如果在迭代输出过程中使用了List中的remove()执行删除操作，则代码将出现问题。
		在使用iterator输出时，不要使用集合类中的remove方法，而只能使用Iterator的remove方法。
		iterator接口的功能时从前向后输出，属于单向的输出；
		在使用iterator时，最后不要删除数据。
	
	7.ListIterator接口：集合输出接口（是Iterator的子接口，双向输出）
		是Iterator接口的子接口，主要功能实现了右前向后、右后向前的双向输出；
		ListIterator接口的定义如下：
			public interface ListIterator<E> extends Iterator<E>
		此接口可以进行双向输出操作，但是在Collection接口中并没有定义可以为此类实例化的操作，只有List接口中才存在了ListIterator接口的实例化操作（通过调用ListIterator()方法实现）。
		常用方法：
			public void add(E e)
				添加操作，将指定元素插入列表；
			public boolean hasPrevious()
				逆向判断是否有内容；
			public E previous()
				返回列表中的前一个元素
			public void set(E e)
				用指定元素替换next或previous返回的最后一个元素；
		
		注意：此操作时，必须先进行由前向后，再进行右后向前的操作。
	                            如果要想使用ListIterator接口，则只能依靠List接口完成；
		
	8.foreach及Enumeration接口：
		foreach输出：
			List<String> allList = new ArrayList<String>();
		
			allList.add("hello");
			allList.add("_");
			allList.add("world");
			
			for(String str : allList){
				System.out.print(str+"、");
			}
		
		Enumeration接口：
			在Java刚出来的时候，使用Enumeration接口完成输出；
			在使用Enumeration输出的时候一般都是直接操作Vector类完成的。
			常用方法：
				public boolean hasMoreElements()
					判断是否有内容；
				public E nextElement()
					输出内容
		注意：在所有的输出操作红，以Iterator接口为最标准的输出操作；
		
	*9.Map接口：	
		本章目标：
			1.掌握Map接口与Collection接口的不同；
			2.掌握Map接口与Map.Entry接口的关系；
			3.掌握Map接口的常用子类：HashMap、Hashtable、TreeMap、WeakHashMap；
			4.掌握HashMap与Hastable的区别。
		之前所讲解的Collection、Set、List接口都属于单值的操作，即每一次只能操作一个对象，而Map与他们不同的是，每次操作的是一对对象，即二元偶对象；
		Map中保存的是一对对象，对象的形式以：key-->value的形式保存的。此接口的定义如下：
			public interface Map<K,V>
		常用方法：
			public void clear()
				清空Map集合；
			public boolean containsKey(Object key)
				判断指定的key是否存在；
			public boolean containsValue(Object value)
				判断指定的value是否存在；
			public Set<Map.Entry<K,V>> entrySet()
				将Map对象变为Set集合；
			public boolean equals(Object o)
				对象比较；
			public V get(Object key)
				根据key取得value；
			public int hashCode()
				返回哈希码；
			public boolean isEmpty()
				判断集合是否为空；
			public Set<K> keySet()
				取得所有的key；
			public V put(K key, V value)
				向集合中加入元素；
			public void putAll(Map<? extends K, ? extends V> t)
				将一个Map集合中的内容加入到另一个Map；
			public V remove(Object key)
				根据key删除value；
			public int size()
				取出集合的长度；
			public Collection<V> values()
				取出全部的value；
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
			