<!-- generated by run.py -->
<xm_sources>

<XPathTutorial id='1'  creator="nicmila@systinet.com">
	<key>absolute path</key>
	<description lang="ita">La sintassi XPath di base &#xE8; simile al sistema di indirizzamento utilizzato all'interno di un filesystem. Se il path inizia con lo slash /, esso rappresenta un percorso assoluto verso l'elemento richiesto.</description>
	<description lang="eng">The basic XPath syntax is similar to filesystem addressing. If the path starts with the slash / , then it represents an absolute path to the required element.</description>
	<description lang="ger">Die grundlegende XPath Syntax ist der Adressierung des Dateisystems ähnlich. Falls der Pfad mit einem Schrägstrich / beginnt, repräsentiert es einen absoluten Pfad zum benötigten Element.</description>
	<description lang="cze">
Základní syntax jazyka XPath je podobný adresování v souborovém
systému (filesystem).
Pokud výraz začíná lomítkem (slash) / , 
pak reprezentuje absolutní cestu k požadovanému elementu.
</description>
	<description lang="fre">La base de la syntaxe XPATH est semblable à celle de l'adressage du système de fichiers. Si le chemin commence par '/', alors il représente un chemin absolu vers l'élément requis. </description>
	<description lang="dut">De basis XPath schrijfwijze kan je vergelijken met het addresseren van bestanden door het besturingssysteem. Als het path begint met een schuine streep, /, dan stelt het een absoluut path voor bij het verplichte element</description>
	<description lang="spa">La sintaxis básica de XPath es similar a la del 
   direccionamiento de ficheros. Un camino que se inicia con '/', 
   representa un camino absoluto hacia el elemento requerido.</description>
	<description lang="rus">Базовый синтаксис языка XPath похож на адресацию в файловой системе. Если путь начинается  с символа '/', то он представляет абсолютный путь к заданному элементу.</description>
	<description lang="chi">基本的XPath语法类似于在一个文件系统中定位文件,如果路径以斜线 / 开始, 那么该路径就表示到一个元素的绝对路径</description>
	<source>
		<AAA>
			<BBB/>
			<CCC/>
			<BBB/>
			<BBB/>
			<DDD>
				<BBB/>
			</DDD>
			<CCC/>
		</AAA>
	</source>
	<example path="/AAA">
	        <p lang="ita">Selezione dell'elemento radice AAA</p>
		<p lang="eng">Select the root element AAA</p>
		<p lang="ger">Wähle das Wurzelelement AAA aus</p>
		<p lang="cze">Vyber kořenový element AAA</p>
		<p lang="fre">Sélectionne l'élément racine AAA</p>
		<p lang="dut">Selecteert het basis element AAA</p>
		<p lang="spa">Selecciona el elemento raiz AAA</p>
		<p lang="rus">Выбирается корневой узел AAA</p>
		<p lang="chi">选择根元素AAA</p>
	</example>
	<example path="/AAA/CCC">
	        <p lang="ita">Selezione di tutti gli elementi CCC che sono figli dell'elemento radice AAA</p>
		<p lang="eng">Select all elements CCC which are children of the root element AAA</p>
		<p lang="ger">Wähle alle CCC Elemente aus, die Kinder des Wurzelelements AAA sind</p>
		<p lang="cze">Vyber všechny elementy CCC, které jsou přímými potomky kořenového elementu AAA</p>
		<p lang="fre">Sélectionne tous les éléments CCC qui sont enfants de l'élément racine AAA</p>
		<p lang="dut">Selecteert alle CCC elementen die kind zijn van het basis element AAA</p>
		<p lang="spa">Selecciona todos los elementos CCC que son hijos del elemento raiz AAA</p>
		<p lang="rus">Выбираются все элементы CCC, являющиеся дочерними по отношению к корневому узлу AAA</p>
		<p lang="chi">选择AAA的所有CCC子元素</p>
	</example>
	<example path="/AAA/DDD/BBB">
	        <p lang="ita">Selezione di tutti gli elementi BBB che sono figli di DDD, a loro volta figli dell'elemento radice AAA</p>
		<p lang="eng">Select all elements BBB which are children of DDD which are children of the root element AAA</p>
		<p lang="ger">Wähle alle BBB Elemente aus, die Kinder von DDD sind, die ihrerseits Kinder des Wurzelelements AAA sind</p>
		<p lang="cze">Vyber všechny elementy BBB, které jsou přímými potomky elementů
DDD, 
které jsou přímými potomky kořenového elemntu AAA</p>
		<p lang="fre">Sélectionne tous les éléments BBB qui sont enfants de DDD, qui sont enfants de l'élément racine AAA</p>
		<p lang="dut">Selecteert alle BBB elementen die kind zijn van de DDD elementen die op hun beurt kind zijn van het basis element AAA</p>
		<p lang="spa">Selecciona todos los elementos BBB que son hijos de DDD, 
      que a su vez son hijos del elemento raiz AAA</p>
		<p lang="rus">Выбираются все элементы BBB, являющиеся детьми элементов DDD, которые в свою очередь являются детьми корневого узла AAA</p>
		<p lang="chi">选择AAA的子元素DDD的所有子元素</p>
	</example>
</XPathTutorial>

<XPathTutorial id='10'  creator="nicmila@systinet.com">
	<key>|</key>
	<description lang="ita">Path distinti possono essere composti tra loro grazie al separatore |</description>
	<description lang="eng">Several paths can be combined with | separator.</description>
	<description lang="ger">Mehrer Pfade können mit dem | Trennzeichen kombiniert werden.</description>
	<description lang="cze">Několik výrazů může být kombinováno pomocí 
separátoru |</description>
	<description lang="fre">
Plusieurs chemins peuvent être combinés avec le séparateur |
</description>
	<description lang="dut">Verschillende paths kunnen gecombineerd worden met de | scheider</description>
	<description lang="spa">Diferentes caminos pueden ser combinados con el separador '|'.</description>
	<description lang="rus">Несколько путей можно скомбинировать с помощью разделителя |.</description>
	<description lang="chi">多个路径可以用分隔符 | 合并在一起</description>
	<source>
		<AAA>
			<BBB/>
			<CCC/>
			<DDD>
				<CCC/>
			</DDD>
			<EEE/>
		</AAA>
	</source>
	<example path="//CCC | //BBB">
	        <p lang="ita">Selezione di tutti gli elementi CCC e BBB</p>
		<p lang="eng">Select all elements CCC and BBB</p>
		<p lang="ger">Wähle alle CCC und BBB Elemente aus</p>
		<p lang="cze">Vyber všechny elementy CCC a BBB</p>
		<p lang="fre">Sélectionne tous les éléments CCC et BBB</p>
		<p lang="dut">Selecteert alle elementen CCC en BBB elemeneten</p>
		<p lang="spa">Selecciona todos los elementos CCC y BBB</p>
		<p lang="rus">Выбираются все элементы CCC и BBB</p>
		<p lang="chi">选择所有的CCC和BBB元素</p>
	</example>
	<example path="/AAA/EEE | //BBB">
	        <p lang="ita">Selezione di tutti gli elementi BBB e degli elementi EEE che sono figli dell'elemento radice AAA</p>
		<p lang="eng">Select all elements BBB and elements EEE which are children of root element AAA</p>
		<p lang="ger">Wähle alle BBB und EEE Elemente aus, die Kinder des Wurzelelements AAA sind</p>
		<p lang="cze">Vyber všechny elementy BBB a elementy EEE, které jsou 
přímými potomky kořenového elementu AAA</p>
		<p lang="fre">Sélectionne tous les éléments BBB et EEE qui sont enfants de l'élément racine AAA</p>
		<p lang="dut">Selecteert alle elementen BBB elementen en EEE elementen die kind zijn van het basiselement AAA</p>
		<p lang="spa">Selecciona todos los elementos BBB y los elementos EEE que son hijos del
      elemento raiz AAA</p>
		<p lang="rus">Выбираются все элементы BBB и все элементы EEE, чьим прямым родителем является корневой элемент AAA</p>
		<p lang="chi">选择所有的BBB元素和所有是AAA的子元素的EEE元素</p>
	</example>
	<example path="/AAA/EEE | //DDD/CCC | /AAA | //BBB">
	        <p lang="ita">Il numero di combinazioni non &#xE8; soggetto a limiti.</p>
		<p lang="eng">Number of combinations is not restricted</p>
		<p lang="ger">Die Anzahl der Kombinationen ist nicht begrenzt</p>
		<p lang="cze">Počet kombinací není omezen</p>
		<p lang="fre">Le nombre de combinaison n'est pas restreinte</p>
		<p lang="dut">Het aantal combinaties is vrij te kiezen</p>
		<p lang="spa">Las posibles combinaciones no estan acotadas </p>
		<p lang="rus">Количество комбинаций не ограничено</p>
		<p lang="chi">可以合并的路径数目没有限制</p>
	</example>
</XPathTutorial>

<XPathTutorial id='11'  creator="nicmila@systinet.com">
	<key>child::</key>
	<key>axes</key>
	<description lang="ita">L'asse child contiene i nodi figli del nodo contestuale. Tale asse &#xE8; quello di default e pu&#xF2; essere omesso.</description>
	<description lang="eng">The child axis contains the children of the context node. The child axis is the default axis and it can be omitted.  </description>
	<description lang="ger">Die "child"-Achse enthält die Kinder des Kontextknotens. Die "child"-Achse ist die Standardachse und kann daher weggelassen werden.</description>
	<description lang="cze">
Osa přímých potomků (child axis) obsahuje všechny přímé potomky
uzlu, který je v kontextu. Tato osa je implicitní a může být
vynechána.</description>
	<description lang="fre">
L'axe enfant contient les enfants du noeud contextuel. L'axe enfant est celui par défaut et il peut être omis
</description>
	<description lang="dut">De child spil bevat de kinderen van de context geleding. De kind spil is de standaard spil en kan weg gelaten worden.</description>
	<description lang="spa">El eje 'child' contiene a los hijos del nodo del contexto. 
   El eje 'child' es el seleccionado por defecto y puede ser omitido.  </description>
	<description lang="rus">Ось child содержит дочерние элементы контекстного узла. Ось child является осью, применяемой по умолчанию, и может быть опущена.</description>
	<description lang="chi">child轴(axis)包含上下文节点的子元素, 作为默认的轴,可以忽略不写. </description>
	<source>
		<AAA>
			<BBB/>
			<CCC/>
		</AAA>
	</source>
	<example path="/AAA">
	        <p lang="ita">Equivalente a /child::AAA</p>
		<p lang="eng">Equivalent of /child::AAA</p>
		<p lang="ger">Entspricht /child::AAA</p>
		<p lang="cze">Ekvivalent k /child::AAA</p>
		<p lang="fre">Equivalent à /child::AAA</p>
		<p lang="dut">Is hetzelfde als /child::AAA</p>
		<p lang="spa">Equivalente a /child::AAA</p>
		<p lang="rus">Эквивалентно выражению /child::AAA</p>
		<p lang="chi">等价于 /child::AAA</p>		
	</example>
	<example path="/child::AAA">
	        <p lang="ita">Equivalente a /AAA</p>
		<p lang="eng">Equivalent of /AAA</p>
		<p lang="ger">Entspricht /AAA</p>
		<p lang="cze">Ekvivalent k /AAA</p>
		<p lang="fre">Equivalent à /AAA</p>
		<p lang="dut">Is hetzelde als /AAA</p>
		<p lang="spa">Equivalente a /AAA</p>
		<p lang="rus">Эквивалентно выражению /AAA</p>
		<p lang="chi">等价于/AAA</p>
	</example>
	<example path="/AAA/BBB">
	        <p lang="ita">Equivalente a /child::AAA/child::BBB</p>
		<p lang="eng">Equivalent of /child::AAA/child::BBB</p>
		<p lang="ger">Entspricht /child::AAA/child::BBB</p>
		<p lang="cze">Ekvivalent k /child::AAA/child::BBB</p>
		<p lang="fre">Equivalent à /child::AAA/child::BBB</p>
		<p lang="dut">Is hetzelfde als /child::AAA/child::BBB</p>
		<p lang="spa">Equivalente a /child::AAA/child::BBB</p>
		<p lang="rus">Эквивалентно /child::AAA/child::BBB</p>
		<p lang="chi">等价于/child::AAA/child::BBB</p>
	</example>
	<example path="/child::AAA/child::BBB">
	        <p lang="ita">Equivalente a /AAA/BBB</p>
		<p lang="eng">Equivalent of /AAA/BBB</p>
		<p lang="ger">Entspricht /AAA/BBB</p>
		<p lang="cze">Ekvivalent k /AAA/BBB</p>
		<p lang="fre">Equivalent à /AAA/BBB</p>
		<p lang="dut">Is hetzelfde als /AAA/BBB</p>
		<p lang="spa">El equivalente de /AAA/BBB</p>
		<p lang="rus">Эквивалентно /AAA/BBB</p>
		<p lang="chi">等价于/AAA/BBB</p>
	</example>
	<example path="/child::AAA/BBB">
	        <p lang="ita">Entrambe le possibilit&#xE0; possono essere combinate.</p>
		<p lang="eng">Both possibilities can be combined</p>
		<p lang="ger">Beide Möglichkeiten können kombiniert werde</p>
		<p lang="cze">Obě možnosti mohou být kombinovány</p>
		<p lang="fre">Les deux possiblilités peuvent être combinées</p>
		<p lang="dut">De mogelijkheden mogen gecombineerd worden</p>
		<p lang="spa">Ambas formas (haciendo explícito el eje 'child' o no)
      pueden ser combinadas</p>
		<p lang="rus">Оба варианта можно использовать одновременно</p>
		<p lang="chi">二者都可以被合并</p>
	</example>
</XPathTutorial>

<XPathTutorial id='12'  creator="nicmila@systinet.com">
	<key>descendant::</key>
	<key>axes</key>
	<description lang="ita">L'asse descendant contiene i discendenti del nodo contestuale; un discendente &#xE8; un figlio o il figlio di un figlio e cos&#xEC; via. Dunque, l'asse descendant non contiene mai nodi di attributo o di namespace.</description>
	<description lang="eng">The descendant axis contains the descendants of the context node; a descendant is a child or a child of a child and so on; thus the descendant axis never contains attribute or namespace nodes</description>
	<description lang="ger">Die "descendant" Achse enthält alle Nachfahren des Kontextknotens; ein Nachfahre ist ein Kind oder ein Kind eines Kindes usw.; daher enthält die "descendant" Achse niemals Attribute oder Namensraumknoten</description>
	<description lang="cze">
Osa potomků (descendant axis) obsahuje potomky uzlu, který
je v kontextu; 
potomek je přímý potomek (dítě, "child") nebo přímý potomek
přímého potomka atd.
Proto osa potomků nikdy neobsahuje uzly typu atribut nebo jmenný prostor.
</description>
	<description lang="fre">
l'axe descendant (descendant) contient les descendants du noeud contextuel; un descendant est un enfant ou un petit enfant etc... Aussi, l'axe descendant ne contient jamais de noeud de type attribut ou des noms d'espace.</description>
	<description lang="dut">De descendant spil bevat de onderdanen van de context geleding, Een onderdaan is een kind of een kind van een kind, zodoende bevat een onderdaan nooit attribuut of namespace geledingen.</description>
	<description lang="spa">El eje 'descendant' contiene a los descendientes del 
   nodo de contexto; los descendientes son los hijos del nodo y sus descendientes; 
   El eje 'descendant' nunca contiene ni atributos ni nodos 'namespace'.
</description>
	<description lang="rus">Ось descendant содержит потомков контекстного узла; потомком является дочерний элемент, дочерний элемент дочернего элемента и так далее; таким образом ось descendant не содержит узлов атрибутов и пространств имен.
</description>
<description lang="chi">descendant (后代)轴包含上下文节点的后代,一个后代是指子节点或者子节点的子节点等等, 因此descendant轴不会包含属性和命名空间节点. </description>
	<source>
		<AAA>
			<BBB>
				<DDD>
					<CCC>
						<DDD/>
						<EEE/>
					</CCC>
				</DDD>
			</BBB>
			<CCC>
				<DDD>
					<EEE>
						<DDD>
							<FFF/>
						</DDD>
					</EEE>
				</DDD>
			</CCC>
		</AAA>
	</source>
	<example path="/descendant::*">
	        <p lang="ita">Selezione di tutti i discendenti della radice del documento: dunque, tutti gli elementi presenti nel documento.</p>
		<p lang="eng">Select all descendants  of document root and therefore all elements</p>
		<p lang="ger">Wähle alle Nachfahren des Wurzelknotens des Dokuments aus - also alle Elemente</p>
		<p lang="cze">Vyber všechny potomky kořenového elementu - tj. všechny elementy</p>
		<p lang="fre">Sélectionne tous les descendants de l'élément racine et donc tous les éléments</p>
		<p lang="dut">Selecteert alle onderdanen van de basisdocument element of anders gezegd alle elementen van het document</p>
		<p lang="spa">Selecciona todos los descendientes de la raiz, es decir, todos los elementos.</p>
		<p lang="rus">Выбираются все потомки корневого узла, то есть все элементы</p>
		<p lang="chi">选择文档根元素的所有后代.即所有的元素被选择</p>
	</example>
	<example path="/AAA/BBB/descendant::*">
	        <p lang="ita">Selezione di tutti i discendenti di /AAA/BBB</p>
		<p lang="eng">Select all descendants of /AAA/BBB</p>
		<p lang="ger">Wähle alle Nachfahren von /AAA/BBB aus</p>
		<p lang="cze">Vyber všechny potomky elementu /AAA/BBB</p>
		<p lang="fre">Sélectionne tous les descendants de /AAA/BBB</p>
		<p lang="dut">Selecteert alle onderdanen van /AAA/BBB</p>
		<p lang="spa">Selecciona todos los descendientes de /AAA/BBB</p>
		<p lang="rus">Выбираются все потомки элементов, соответствующих пути /AAA/BBB</p>
		<p lang="chi">选择/AAA/BBB的所有后代元素</p>
	</example>
	<example path="//CCC/descendant::*">
	        <p lang="ita">Selezione di tutti gli elementi che presentano CCC fra i loro progenitori.</p>
		<p lang="eng">Select all elements which have CCC among its ancestors</p>
		<p lang="ger">Wähle alle Elemente aus, die CCC unter ihren Vorfahren haben</p>
		<p lang="cze">Vyber všechny elementy, které mají za předka element CCC</p>
		<p lang="fre">Sélectionne tous les éléments qui ont CCC comme ancêtre</p>
		<p lang="dut">Selecteert alle element die het CCC element als onderdaan hebben</p>
		<p lang="spa">Selecciona todos elementos con un ancestro CCC</p>
		<p lang="rus">Выбираются все элементы, имеющие в качестве предка элемент CCC</p>
		<p lang="chi">选择在祖先元素中有CCC的所有元素</p>
	</example>
	<example path="//CCC/descendant::DDD">
	        <p lang="ita">Selezione degli elementi DDD che presentano CCC fra i loro progenitori.</p>
		<p lang="eng">Select elements DDD which have CCC among its ancestors</p>
		<p lang="ger">Wähle alle DDD Elemente aus, die CCC unter ihren Vorfahren haben</p>
		<p lang="cze">Vyber elemnty DDD, které mají element CCC jako předka</p>
		<p lang="fre">Sélectionne les éléments DDD qui ont CCC comme ancêtre</p>
		<p lang="dut">Selecteert alle DDD elementen die een CCC element als onderdaan hebben</p>
		<p lang="spa">Selecciona todos elementos DDD con un ancestro CCC</p>
		<p lang="rus">Выбираются элементы DDD, имеющие в качестве предка элемент CCC</p>
		<p lang="chi">选择所有以CCC为祖先元素的DDD元素</p>
	</example>
</XPathTutorial>

<XPathTutorial id='13'  creator="nicmila@systinet.com">
	<key>parent::</key>
	<key>axes</key>
	<description lang="ita">L'asse parent contiene (se esiste) il genitore del nodo contestuale.</description>
	<description lang="eng">The parent axis contains the parent of the context node, if there is one.</description>
	<description lang="ger">Die "parent" Achse enthält den Elternknoten des Kontextknotens, falls ein solches existiert.</description>
	<description lang="cze">
Osa rodičů (parent axis) obsahuje rodiče uzlu, který je v kontextu - pokud ovšem existují.
</description>
	<description lang="fre">
L'axe "parent" contient le parent du noeud contextuel s'il en a un
</description>
	<description lang="dut">De parent spil bevat de ouder van de context geleding, als er al een is</description>
	<description lang="spa">El eje 'parent' contiene el padre del nodo del contexto, 
   si éste existe.</description>
	<description lang="rus">Ось parent содержит родителя контекстного узла, если он существует.</description>
	<description lang="chi">parent轴(axis)包含上下文节点的父节点, 如果有父节点的话</description>
	<source>
		<AAA>
			<BBB>
				<DDD>
					<CCC>
						<DDD/>
						<EEE/>
					</CCC>
				</DDD>
			</BBB>
			<CCC>
				<DDD>
					<EEE>
						<DDD>
							<FFF/>
						</DDD>
					</EEE>
				</DDD>
			</CCC>
		</AAA>
	</source>
	<example path="//DDD/parent::*">
	        <p lang="ita">Selezione di tutti i nodi genitore dell'elemento DDD</p>
		<p lang="eng">Select all parents of DDD element</p>
		<p lang="ger">Wähle alle Eltern von DDD Elementen aus</p>
		<p lang="cze">Vyber všechny rodiče elementů DDD</p>
		<p lang="dut">Selecteert alle ouders van het DDD element</p>
		<p lang="spa">Selecciona el padres de cada elemento DDD</p>
		<p lang="rus">Выбираются все родители элемента DDD </p>
		<p lang="chi">选择DDD元素的所有父节点</p>
	</example>
</XPathTutorial>

<XPathTutorial id='14'  creator="nicmila@systinet.com">
	<key>ancestor::</key>
	<key>axes</key>
	<description lang="ita">L'asse ancestor contiene i progenitori del nodo contestuale: i progenitori del nodo contestuale consistono nel genitore del nodo contestuale, nel genitore del genitore e cos&#xEC; via. Dunque, l'asse ancestor contiene sempre il nodo radice, tranne nel caso in cui il nodo contestuale sia esso stesso il nodo radice.</description>
	<description lang="eng">The ancestor axis contains the ancestors of the context node; the ancestors of the context node consist of the parent of   context node and the parent's parent and so on; thus, the ancestor axis will always include the root node, unless the context node is the root node.
</description>
	<description lang="ger">Die "ancestor" Achse enthält die Vorfahren eines Kontextknotens. Die Vorfahren eines Kontextknotens bestehen aus dem Elternknoten des Kontextknotens und die Elternknoten der Elternknoten usw. Daher enthält die "ancestor" Achse immer den Wurzelknoten, es sei denn der Wurzelknoten ist nicht der Kontextknoten.</description>
	<description lang="cze">
Osa předků obsahuje předku uzlu, který je v kontextu;
předkové tohoto uzlu jsou rodiče, rodiče rodičů atd.
Proto osa předků vždy obsahuje kořen dokumentu,
pokud ovšem uzlem v kontextu není sám kořen dokumentu.
</description>
	<description lang="fre">
l'axe ancêtre (ancestor) contient les ancêtres du noeud contextuel; cela comprend son parent et les parents des parents etc... Aussi, cet axe contient toujours le noeud racine, sauf si le noeud contextuel est lui-même la racine.
</description>
	<description lang="dut">De ancestor spil bevat de onderdanen van de context geleding. De onderdanen van de context geleding bestaan uit de ouder van de context geleding en de ouder van de ouder enzovoort. Zodoende dat de onderdaan spil altijd de basis geleding bevat tenzij de contexxt gelding de basis geleding is.</description>
	<description lang="spa">El eje 'ancestor' contiene los ancestros del nodo 
   del contexto, que son el padre del nodo y sus ancestros; 
   Se deduce entonces que el eje 'ancestor' de un patron correspondiente
   a al menos un nodo contiene el elemento raiz salvo en 
   el caso de que el contexto especifique únicamente la raiz misma.</description>
	<description lang="rus">Ось ancestor содержит предков контекстного узла; предками контесктного узла являются родитель контесктного узла, родитель родителя и так далее; Таким образом, ось ancestor всегда включает корневой узел, заисключением случая, когда контекстный узел является корневым.</description>
	<description lang="chi">ancestor轴(axis)包含上下节点的祖先节点, 该祖先节点由其上下文节点的父节点以及父节点的父节点等等诸如此类的节点构成,所以ancestor轴总是包含有根节点,除非上下文节点就是根节点本身.</description>
	<source>
		<AAA>
			<BBB>
				<DDD>
					<CCC>
						<DDD/>
						<EEE/>
					</CCC>
				</DDD>
			</BBB>
			<CCC>
				<DDD>
					<EEE>
						<DDD>
							<FFF/>
						</DDD>
					</EEE>
				</DDD>
			</CCC>
		</AAA>
	</source>
	<example path="/AAA/BBB/DDD/CCC/EEE/ancestor::*">
	        <p lang="ita">Selezione di tutti gli elementi che figurano in questo path assoluto.</p>
		<p lang="eng">Select all elements given in this absolute path</p>
		<p lang="ger">Wähle alle Elemente im angegebenen absoluten Pfad aus</p>
		<p lang="cze">Vyber všechny elementy, které jsou uvedeny v této absolutní cestě</p>
		<p lang="fre">Séléctionne tous les éléments donnés dans ce chemin absolu</p>
		<p lang="dut">Selecteert alle elementen van dit exacte path</p>
		<p lang="spa">Selecciona exactamente los elementos que aparecen en este 
      camino absoluto</p>
		<p lang="rus">Выбираются все узлы, перечисленные в этом абсолютном пути</p>
		<p lang="chi">选择一个绝对路径上的所有节点</p>
	</example>
	<example path="//FFF/ancestor::*">
	        <p lang="ita">Selezione dei progenitori dell'elemento FFF</p>
		<p lang="eng">Select ancestors of FFF element</p>
		<p lang="ger">Wähle alle Vorfahren vom FFF Element aus</p>
		<p lang="cze">Vyber všechny předky elementů FFF</p>
		<p lang="fre">Séléctionne tous les ancêtres de l'élément FFF</p>
		<p lang="dut">Selecteert de onderdanen van het FFF element</p>
		<p lang="spa">Selecciona los ancestros de cada elemento FFF</p>
		<p lang="rus">Выбираются все предки элемента FFF</p>
		<p lang="chi">选择FFF元素的祖先节点</p>
	</example>
</XPathTutorial>

<XPathTutorial id='15'  creator="nicmila@systinet.com">
	<key>following-sibling::</key>
	<key>axes</key>
	<description lang="ita">L'asse following-sibling contiene tutti i successivi nodi-fratello del nodo contestuale.</description>
	<description lang="eng">The following-sibling axis contains all the following siblings of the context node.</description>
	<description lang="ger">Die "following-sibling" Achse enthält alle folgenden Geschwister des Kontextknotens.</description>
	<description lang="cze">
Osa "following-sibling" obsahuje všechny následující sourozence
uzlu, který je v kontextu.
</description>
	<description lang="fre">
l'axe 'following-sibling' contient tous les noeuds frères qui suivent le noeud contextuel.
</description>
	<description lang="dut">De following-sibling spil bevat alle volgende afstammelingen van de context geleding.</description>
	<description lang="spa">El eje 'following-sibling' contiene todos los nodos 
   hermanos que siguen el nodo del contexto.</description>
	<description lang="rus">Ось following-sibling содержит все следующих братьев контекстного узла. Братьями называются те узлы, что имеют одного родителя с контекстным.</description>
	<description lang="chi">following-sibling轴(axis)包含上下文节点之后的所有兄弟节点</description>
	<source>
		<AAA>
			<BBB>
				<CCC/>
				<DDD/>
			</BBB>
			<XXX>
				<DDD>
					<EEE/>
					<DDD/>
					<CCC/>
					<FFF/>
					<FFF>
						<GGG/>
					</FFF>
				</DDD>
			</XXX>
			<CCC>
				<DDD/>
			</CCC>
		</AAA>
	</source>
	<example path="/AAA/BBB/following-sibling::*">
		<p lang="rus"/>
	</example>
	<example path="//CCC/following-sibling::*">
		<p lang="rus"/>
	</example>
</XPathTutorial>

<XPathTutorial id='16'  creator="nicmila@systinet.com">
	<key>preceding-sibling::</key>
	<key>axes</key>
	<description lang="ita">L'asse preceding-sibling contiene tutti i precedenti nodi-fratello del nodo contestuale.</description>
	<description lang="eng">The preceding-sibling axis contains all the preceding siblings of the context node</description>
	<description lang="ger">The "preceding-sibling" Achse enthält alle vorangehend Geschwister im Kontextknoten</description>
	<description lang="cze">
Osa "preceding-sibling" obsahuje všechny předcházející sourozence
uzlu, který je v kontextu.
</description>
	<description lang="fre">
L'axe 'preceding-sibling' contient tous les frères prédécesseurs du noeud contextuel; si le noeud contextuel est un attribut ou un espace de noms, la cible précédente est vide.
</description>
	<description lang="dut">De preceding-sibling spil bevat alle voorgaande afstammelingen van de context geleding.</description>
	<description lang="spa">El eje 'preceding-sibling' contiene todos los elementos hermanos
   que preceden el nodo del contexto.</description>
	<description lang="rus">Ось preceding-sibling содержит всех предыдущих братьев контекстного узла.</description>
	<description lang="chi">preceding-sibling 轴(axis)包含上下文节点之前的所有兄弟节点</description>
	<source>
		<AAA>
			<BBB>
				<CCC/>
				<DDD/>
			</BBB>
			<XXX>
				<DDD>
					<EEE/>
					<DDD/>
					<CCC/>
					<FFF/>
					<FFF>
						<GGG/>
					</FFF>
				</DDD>
			</XXX>
			<CCC>
				<DDD/>
			</CCC>
		</AAA>
	</source>
	<example path="/AAA/XXX/preceding-sibling::*">
		<p lang="rus"/>
	</example>
	<example path="//CCC/preceding-sibling::*">
		<p lang="rus"/>
	</example>
</XPathTutorial>

<XPathTutorial id='17'  creator="nicmila@systinet.com">
	<key>following::</key>
	<key>axes</key>
	<description lang="ita">L'asse following contiene tutti i nodi che sono presenti nello stesso documento del nodo contestuale e che sono successivi rispetto a esso secondo l'ordine del documento, esclusi nodi discendenti, di attributo o di namespace.</description>
	<description lang="eng">The following axis contains all nodes in the same document as the context node that are after the context node in document order, excluding any descendants and excluding attribute nodes and namespace nodes.</description>
	<description lang="ger">Die "following" Achse enthält alle Knoten im gleichen Dokument als Kontextknoten, die sich in der Reihenfolge des Dokuments nach dem Kontextknoten befinden. Nachfahren sowie Attribut- und Namensraumknoten sind hierbei ausgeschlossen.</description>
	<description lang="cze">
Osa "following" ("následující") obsahuje všechny uzly v tom samém
dokumentu, které se vyskytují po uzlu, který je v kontextu,
a to podle pořadí v dokumentu ("document order") a vyjma
jakýchkoli potomků, atributů a uzlů jmenných prostorů.
</description>
	<description lang="fre">
l'axe suivant (following) tous les noeuds du même document que le noeud contextuel qui sont après le noeud contextuel dans l'ordre du document, à l'exclusion de tout descendant, des attributs et des espaces de noms.
</description>
	<description lang="dut">De following spil bevat alle geledingen die in hetzelfde document staan als de context geleding die na de context geleding komen in het document behalve de onderdanige elementen en de attribuut en namespace geledingen.</description>
	<description lang="spa">El eje 'following' contiene todos los nodos del documento
   que se encuentran luego del nodo del contexto. Esto no incluye ancestros, descendientes,
   nodos de atributo ni nodos 'namespace'.</description>
	<description lang="rus">Ось following содержит в том же порядке, что и в самом документе, все узлы, идущие после контекстного, за исключением всех потомков, узлов атрибутов и пространств имен.</description>
	<description lang="chi">following轴(axis)包含同一文档中按文档顺序位于上下文节点之后的所有节点, 除了祖先节点,属性节点和命名空间节点</description>
	<source>
		<AAA>
			<BBB>
				<CCC/>
				<ZZZ>
					<DDD/>
					<DDD>
						<EEE/>
					</DDD>
				</ZZZ>
				<FFF>
					<GGG/>
				</FFF>
			</BBB>
			<XXX>
				<DDD>
					<EEE/>
					<DDD/>
					<CCC/>
					<FFF/>
					<FFF>
						<GGG/>
					</FFF>
				</DDD>
			</XXX>
			<CCC>
				<DDD/>
			</CCC>
		</AAA>
	</source>
	<example path="/AAA/XXX/following::*">
		<p lang="rus"/>
	</example>
	<example path="//ZZZ/following::*">
		<p lang="rus"/>
	</example>
</XPathTutorial>

<XPathTutorial id='18'  creator="nicmila@systinet.com">
	<key>preceding::</key>
	<key>axes</key>
	<description lang="ita">L'asse preceding contiene tutti i nodi che sono presenti nello stesso documento del nodo contestuale e che sono precedenti rispetto a esso secondo l'ordine del documento, esclusi nodi progenitori, di attributo o di namespace</description>
	<description lang="eng">The preceding axis contains all nodes in the same document as the context node that are before the context node in  document order, excluding any ancestors and excluding attribute nodes and namespace nodes</description>
	<description lang="ger">Die "preceding" Achse enthält alle Knoten im gleichen Dokument als Kontextknoten, die sich in der Reihenfolge des Dokuments vor dem Kontextknoten befinden. Nachfahren sowie Attribut- und Namensraumknoten sind hierbei ausgeschlossen.</description>
	<description lang="cze">
Osa "preceding" (předcházející) obsahuje všechny uzly v tom samém
dokumentu, které se vyskytují po uzlu, který je v kontextu,
a to podle pořadí v dokumentu ("document order") a vyjma
jakýchkoli předků, atributů a uzlů jmenných prostorů.
</description>
	<description lang="fre">l'axe cible précédente (preceding-sibling) contient tous les prédécesseurs du noeud contextuel; si le noeud contextuel est un attribut ou un espace de noms, la cible précédente est vide.</description>
	<description lang="dut">De preceding spil bevat alle geledingen die in hetzelfde documentstaan als de context geleding voor de context geleding behalve de ouder elementen en de atribuut en namespace geledingen.</description>
	<description lang="spa">El eje 'preceding' contiene todos los nodos del documento
   que se encuentran antes del nodo del contexto. Esto no incluye ancestros, descendientes,
   nodos de atributo ni nodos 'namespace'.</description>
	<description lang="rus">Ось preceding содержит в том же порядке, что и в самом документе, все узлы, идущие перед контекстным узлом, исключая любых предков, узлов атрибутов и пространств имен.</description>
	<description lang="chi">following轴(axis)包含同一文档中按文档顺序位于上下文节点之前的所有节点, 除了祖先节点,属性节点和命名空间节点</description>
	<source>
		<AAA>
			<BBB>
				<CCC/>
				<ZZZ>
					<DDD/>
				</ZZZ>
			</BBB>
			<XXX>
				<DDD>
					<EEE/>
					<DDD/>
					<CCC/>
					<FFF/>
					<FFF>
						<GGG/>
					</FFF>
				</DDD>
			</XXX>
			<CCC>
				<DDD/>
			</CCC>
		</AAA>
	</source>
	<example path="/AAA/XXX/preceding::*">
		<p lang="rus"/>
	</example>
	<example path="//GGG/preceding::*">
		<p lang="rus"/>
	</example>
</XPathTutorial>

<XPathTutorial id='19'  creator="nicmila@systinet.com">
	<key>descendant-or-self::</key>
	<key>axes</key>
	<description lang="ita">L'asse descendant-or-self contiene il nodo contestuale e i suoi discendenti.</description>
	<description lang="eng">The descendant-or-self axis contains the context node and the descendants of the context node</description>
	<description lang="ger">Die "descendant-or-self" Achse enthält den Kontextknoten und die Nachfahren des Kontextknotens</description>
	<description lang="cze">
Osa "descendant-or-self" obsahuje kontextový uzel
a všechny jeho potomky
</description>
	<description lang="fre">
L'axe "descendant-or-self" contient le noeud contextuel et ses descendants
</description>
	<description lang="dut">De descendant-or-self spil bevat de context geleding en zijn onderdanige elementen.</description>
	<description lang="spa">El eje 'descendant-or-self' contiene el nodo
   contexto y sus descendentes.</description>
	<description lang="rus">Ось descendant-or-self содержит контекстный узел и всех его потомков.</description>
	<description lang="chi">descendant-or-self 轴(axis)包含上下文节点本身和该节点的后代节点</description>
	<source>
		<AAA>
			<BBB>
				<CCC/>
				<ZZZ>
					<DDD/>
				</ZZZ>
			</BBB>
			<XXX>
				<DDD>
					<EEE/>
					<DDD/>
					<CCC/>
					<FFF/>
					<FFF>
						<GGG/>
					</FFF>
				</DDD>
			</XXX>
			<CCC>
				<DDD/>
			</CCC>
		</AAA>
	</source>
	<example path="/AAA/XXX/descendant-or-self::*">
		<p lang="rus"/>
	</example>
	<example path="//CCC/descendant-or-self::*">
		<p lang="rus"/>
	</example>
</XPathTutorial>

<XPathTutorial id='2'  creator="nicmila@systinet.com">
	<key>//</key>
	<description lang="ita">Se il path inizia con // allora vengono selezionati tutti gli elementi del documento che soddisfano i criteri successivi.</description>
	<description lang="eng">If the path starts with // then all elements in the document which fulfill following criteria are selected.</description>
	<description lang="ger">Falls der Pfad mit // beginnt, werden alle Elemente ausgewählt, welche die folgenden Kriterien erfüllen.</description>
	<description lang="cze">
Pokud výraz začíná // (dvěma lomítky), pak jsou vybrány všechny
elementy kdekoli v dokumentu, které splňují následující kritéria
</description>
	<description lang="fre">
Si le chemin commence par '//', alors tous les éléments du document qui correspondent au critère qui suit sont sélectionnés.
</description>
	<description lang="dut">Als het path begint met // dan zullen alle elementen van het document die overeenkomen met de erna volgende criteria geselecteerd worden.</description>
	<description lang="spa">Cuando el camino se inicia con '//' todos los elementos
   en el documento que cumplen con el criterio que sigue son seleccionados.</description>
	<description lang="rus">Если путь начинается с //, то будут выбраны все элементы документа, которые соответствуют указанному шаблону.</description>
	<description lang="chi">如果路径以双斜线 // 开头, 则表示选择文档中所有满足双斜线//之后规则的元素(无论层级关系)</description>
	<source>
		<AAA>
			<BBB/>
			<CCC/>
			<BBB/>
			<DDD>
				<BBB/>
			</DDD>
			<CCC>
				<DDD>
					<BBB/>
					<BBB/>
				</DDD>
			</CCC>
		</AAA>
	</source>
	<example path="//BBB">
		<p lang="ita">Selezione di tutti gli elementi BBB</p>
		<p lang="eng">Select all elements BBB</p>
		<p lang="ger">Wähle alle BBB Elemente aus</p>
		<p lang="cze">Vyber všechny elementy BBB</p>
		<p lang="fre">Sélectionne tous les éléments BBB</p>
		<p lang="spa">Selecciona todos los elementos BBB</p>
		<p lang="rus">Будут выбраны все элементы BBB</p>
		<p lang="chi">选择所有BBB元素</p>
	</example>
	<example path="//DDD/BBB">
	        <p lang="ita">Selezione di tutti gli elementi BBB che sono figli di DDD</p>
		<p lang="eng">Select all elements BBB which are children of DDD</p>
		<p lang="ger">Wähle alle BBB Elemente aus, die Kinder von DDD sind</p>
		<p lang="cze">Vyber všechny elementy BBB, které jsou přímými potomky DDD</p>
		<p lang="fre">Sélectionne tous les éléments BBB qu sont enfants de DDD</p>
		<p lang="dut">Selecteert alle BBB elementen die kind zijn van DDD</p>
		<p lang="spa">Selecciona todos los elementos BBB que son hijos de DDD</p>
		<p lang="rus">Будут выбраны все элементы BBB, являющиеся детьми DDD</p>
		<p lang="chi">选择所有父元素是DDD的BBB元素</p>
	</example>
</XPathTutorial>

<XPathTutorial id='20'  creator="nicmila@systinet.com">
	<key>ancestor-or-self::</key>
	<key>axes</key>
	<description lang="ita">L'asse ancestor-or-self contiene il nodo contesuale e i suoi progenitori: dunque, l'asse ancestor-or-self includer&#xE0; sempre il nodo radice.</description>
	<description lang="eng">The ancestor-or-self axis contains the context node and the ancestors of the context node; thus, the ancestor-or-self axis will always include the root node.
</description>
	<description lang="ger">Die "ancestor-or-self" Achse enthält den Kontextknoten und die Vorfahren des Knotextknotens. Somit enthält die "ancestor-or-self" Achse immer den Wurzelknoten.</description>
	<description lang="cze">
Osa "ancestor-or-self" obsahuje kontextový uzel a všechny jeho předky.
Proto bude vždy obsahovat kořen dokumentu.
</description>
	<description lang="fre">
L'axe ancestor-or-self contient le noeud contextuel et ses ancêtres; ainsi l'axe ancestor-or-self contient toujours le noeud racine
</description>
	<description lang="dut">De ancestor-or-self spil bevat de context geleding en zijn ouders zodoende dat de ouder spil altijd de basis geleding bevat.</description>
	<description lang="spa">El eje 'ancestor-or-self' contiene el nodo del 
   contexto así como sus ancestros; El eje 'ancestor-or-self' contiene el nodo 
   raiz salvo en el caso donde el patron que precede al eje no especifique 
   ningún nodo del documento.</description>
	<description lang="rus">Ось ancestor-or-self содержит контекстный узел и всех его предков; таким образом, эта ось всегда содержит корневой узел.</description>
	<description lang="chi"> ancestor-or-self 轴(axis)包含上下文节点本身和该节点的祖先节点</description>
	<source>
		<AAA>
			<BBB>
				<CCC/>
				<ZZZ>
					<DDD/>
				</ZZZ>
			</BBB>
			<XXX>
				<DDD>
					<EEE/>
					<DDD/>
					<CCC/>
					<FFF/>
					<FFF>
						<GGG/>
					</FFF>
				</DDD>
			</XXX>
			<CCC>
				<DDD/>
			</CCC>
		</AAA>
	</source>
	<example path="/AAA/XXX/DDD/EEE/ancestor-or-self::*">
		<p lang="rus"/>
	</example>
	<example path="//GGG/ancestor-or-self::*">
		<p lang="rus"/>
	</example>
</XPathTutorial>

<XPathTutorial id='21'  creator="nicmila@systinet.com">
	<key>ancestor::</key>
	<key>descendant::</key>
	<key>following::</key>
	<key>preceding::</key>
	<key>self::</key>
	<key>axes</key>
	<description lang="ita">Gli assi ancestor, descendant, following, preceding e self partizionano un documento (ignorando gli attributi e i nodi di namespace). Il contenuto di tali assi &#xE8; differente l'uno dagli altri e congiuntamente rappresentano l'insieme di tutti i nodi del documento.</description>
	<description lang="eng"> The ancestor, descendant, following, preceding and self axes partition a document (ignoring
    attribute and namespace nodes): they do not overlap and together they contain all the nodes in the document.</description>
	<description lang="ger">Die "ancestor" (Vorfahren), "descendant" (Nachfahren), "following" (folgenden), "preceding" (vorangehend) and "self" (selbst) Achsen teilen ein Dokument auf (und ignorieren dabei die Attribut- und Namensraumsknoten): Sie überlappen sich nicht gegenseitig und enthalten zusammen alle Knoten in einem Dokument.</description>
	<description lang="cze">
Osy "ancestor", "descendant", "following", "preceding" a "self"
rozdělují dokument
(ignorujíc uzly typu atribut a jmenný prostor):
nepřekrývají se a dohromady obsahují všechny uzly dokumentu.
</description>
	<description lang="fre">
Les axes ancestors, descendants, following, preceding et self partitionnent un document (ignorant les attributs et les noeuds d'espace de nom) : il ne se chevauchent pas et ensemble ils contiennent tous les noeuds d'un document
</description>
	<description lang="dut">De ancestor, descendant, following, preceding en self spillen verdelen een document, niet kijkende naar de attribuut en namespace geledingen. Ze overlappen elkaar niet maar samen kunnen ze wel alle geledingen bevatten van het document.</description>
	<description lang="spa"> Para un camino que especifica un único elemento
   de un documento, los ejes 'ancestor', 'descendant', 'following', 
   'preceding' y 'self' constituyen una partición de ese documento
   (no tomando en cuenta nodos de atributos ni de 'namespace'): 
   No tienen nodos en comun y juntos especifican todos los nodos del documento.
</description>
	<description lang="rus">Оси ancestor, descendant, following, preceding и self axes покрывают документ (за исключением узлов атрибутов и пространств имен): они не перескаются и вместе содержат все узлы документа.</description>
	<description lang="chi">ancestor, descendant, following, preceding 和self轴(axis)分割了XML文档(忽略属性节点和命名空间节点), 不能交迭, 而一起使用则包含所有节点</description>
	<source>
		<AAA>
			<BBB>
				<CCC/>
				<ZZZ/>
			</BBB>
			<XXX>
				<DDD>
					<EEE/>
					<FFF>
						<HHH/>
						<GGG>
							<JJJ>
								<QQQ/>
							</JJJ>
							<JJJ/>
						</GGG>
						<HHH/>
					</FFF>
				</DDD>
			</XXX>
			<CCC>
				<DDD/>
			</CCC>
		</AAA>
	</source>
	<example path="//GGG/ancestor::*">
		<p lang="rus"/>
	</example>
	<example path="//GGG/descendant::*">
		<p lang="rus"/>
	</example>
	<example path="//GGG/following::*">
		<p lang="rus"/>
	</example>
	<example path="//GGG/preceding::*">
		<p lang="rus"/>
	</example>
	<example path="//GGG/self::*">
		<p lang="rus"/>
	</example>
	<example path="//GGG/ancestor::* | //GGG/descendant::* | //GGG/following::* | //GGG/preceding::* | //GGG/self::*">
		<p lang="rus"/>
	</example>
</XPathTutorial>

<XPathTutorial id='22'  creator="nicmila@systinet.com">
	<key>position()</key>
	<key>mod</key>
	<key>div</key>
	<key>floor()</key>
	<key>ceiling()</key>
	<key>last()</key>
	<description lang="ita">L'operatore div esegue una divisione a virgola mobile, l'operatore mod restituisce il resto di una divisione con troncamento. La funzione floor() restituisce l'intero pi&#xF9; grande minore del suo argomento. La funzione ceiling() restituisce l'intero pi&#xF9; piccolo maggiore del suo argomento.</description>
	<description lang="eng">The div operator performs floating-point division, the mod operator returns the remainder from a truncating division. The floor function returns the largest (closest to positive infinity) number that is not greater than the argument and that is an integer.The ceiling function returns the smallest (closest to negative infinity) number that is not less than the argument and that is an integer. 
</description>
	<description lang="ger">Der "div" Operator führt Divisionen mit Gleitkommazahlen durch. Der "mod" Operator liefert den Rest einer nicht aufgehenden Division zurück. Die "floor()" Funktion liefert die größte (am nächsten bei Plus-Unendlich liegende) Zahl zurück, die nicht größer als ihr Argument ist und eine Integerzahl ist. Die "ceiling ()" Funktion liefert die kleinste (am nächsten bei Minus-Unendlich liegende) Zahl zurück, die nicht kleiner als ihr Argument ist und eine Integerzahl ist.</description>
	<description lang="cze">
Operátor "div" provádí dělení (neceločíselné), 
operátor "mod" vrací zbytek po celočíselném dělení.
Funkce "floor" vrací nejvyšší (bližší k plus nekonečnu)
celé číslo, které není vyšší než argument.
Funkce "ceiling" nejmenší (bližší k minus nekonečnu)
celé číslo, které není menší než argument.
</description>
	<description lang="fre">
L'opérateur div réalise une division à virgule flottante, l'opérateur mod retourne le reste d'une division. La fonction floor() retourne le plus grand nombre (le plus près de l'infini positif) qui n'est pas plus grand que l'argument et qui est un entier. La fonction ceiling() retourne le plus petit nombre (le plus près de l'infini négatif) qui n'est pas plus petit que l'argument et qui est un entier</description>
	<description lang="dut">De div operator maakt komma getal delingen; De mod operator geeft de rest weer van een staartdeling. De floor functie geeft het grootste getal weer, dichtst bij het positieve oneindige, dat niet groter is dan het argument en geheel is. De ceiling functie geeft het kleinste getal weer, dichtst bij het negatieve oneindige, dat niet kleiner is dan het het argument en geheel is.</description>
	<description lang="spa">El operador 'div' realiza divisiones en punto flotante,
   el operador 'mod' calcula el residuo entero de la división. 
   El operador 'floor' calcula el más grande entero que no es mayor que el argumento.
   la función 'ceiling' produce el mas pequeño entero que no es menor que el argumento.</description>
	<description lang="rus">Оператор div производит деление, оператор mod возвращает остаток от деления нацело. Функция  floor возвращает максимальное целое чило, не большее аргумента. Функция ceiling возвращает минимальное целое число, не меньшее аргумента.</description>
	<description lang="chi">div运算符做浮点除法运算, mod运算符做求余运算, floor函数返回不大于参数的最大整数(趋近于正无穷), ceiling返回不小于参数的最小整数(趋近于负无穷)</description>
	<source>
		<AAA>
			<BBB/>
			<BBB/>
			<BBB/>
			<BBB/>
			<BBB/>
			<BBB/>
			<BBB/>
			<BBB/>
			<CCC/>
			<CCC/>
			<CCC/>
		</AAA>
	</source>
	<example path="//BBB[position() mod 2 = 0 ]">
	        <p lang="ita">Selezione degli elementi BBB localizzati in posizioni pari.</p>
		<p lang="eng">Select even BBB elements</p>
		<p lang="ger">Wähle alle BBB Elemente aus, deren Position eine gerade Zahl ausmacht</p>
		<p lang="rus"/>
		<p lang="chi">选择偶数位置的BBB元素</p>
	</example>
	<example path="//BBB[ position() = floor(last() div 2 + 0.5) or position() = ceiling(last() div 2 + 0.5) ]">
                <p lang="ita">Selezione dell'elemento (o degli elementi) BBB localizzato in posizioni centrali.</p>
		<p lang="eng">Select  middle BBB element(s)</p>
		<p lang="ger">Wähle das/die mittlere(n) BBB Element(e) aus</p>
		<p lang="rus"/>
		<p lang="chi">选择中间的BBB元素</p>
	</example>
	<example path="//CCC[ position() = floor(last() div 2 + 0.5) or position() = ceiling(last() div 2 + 0.5) ]">
                <p lang="ita">Selezione dell'elemento (o degli elementi) CCC localizzato in posizioni centrali.</p>
		<p lang="eng">Select  middle CCC element(s)</p>
		<p lang="ger">Wähle das/die mittlere(n) CCC Element(e) aus</p>
		<p lang="rus"/>
		<p lang="chi">选择中间的CCC元素</p>
	</example>
</XPathTutorial>

<XPathTutorial id='3'  creator="nicmila@systinet.com">
	<key>*</key>
	<key>//</key>
	<description lang="ita">L'asterisco * seleziona tutti gli elementi localizzati dal path precedente.</description>
	<description lang="eng">The star * selects all elements located by preceeding path</description>
	<description lang="ger">Der Stern * wählt alle Elemente aus, die durch den vorangehenden Pfades lokalisiert werden</description>
	<description lang="cze">
Hvězdička * vybere všechny elementy, které jsou určeny předcházejícím výrazem
</description>
	<description lang="fre">
L'étoile * sélectionne tous les éléments localisés par ce qui la précède dans le chemin
</description>
	<description lang="dut">Een ster * selecteert alle elementen gelocaliseerd door het voorgaande path.</description>
	<description lang="spa">El asterisco '*' selecciona todos los elementos ubicados por el camino que lo precede.</description>
	<description lang="rus">Символ '*' указывает, что надо выбрать все элементы, соответствующие пути перед ней.</description>
	<description lang="chi">星号 * 表示选择所有由星号之前的路径所定位的元素</description>
	<source>
		<AAA>
			<XXX>
				<DDD>
					<BBB/>
					<BBB/>
					<EEE/>
					<FFF/>
				</DDD>
			</XXX>
			<CCC>
				<DDD>
					<BBB/>
					<BBB/>
					<EEE/>
					<FFF/>
				</DDD>
			</CCC>
			<CCC>
				<BBB>
					<BBB>
						<BBB/>
					</BBB>
				</BBB>
			</CCC>
		</AAA>
	</source>
	<example path="/AAA/CCC/DDD/*">
	        <p lang="ita">Selezione di tutti gli elementi inclusi nel percorso /AAA/CCC/DDD</p>
		<p lang="eng">Select all elements enclosed by elements /AAA/CCC/DDD</p>
		<p lang="ger">Wähle alle Elemente aus, die von den /AAA/CCC/DDD Elementen eingeschlossen sind</p>
		<p lang="cze">Vyber všechny elementy, které jsou přímými potomky /AAA/CCC/DDD</p>
		<p lang="fre">Sélectionne tous les éléments inclus dans les éléments /AAA/CCC/DDD</p>
		<p lang="dut">Selecteert alle elementen die zich bevinden in het path /AAA/CCC/DDD</p>
		<p lang="spa">Selecciona todos los elementos contenidos en el camino /AAA/CCC/DDD</p>
		<p lang="rus">Будут выбраны все элементы, являющиеся прямыми потомками /AAA/CCC/DDD</p>
		<p lang="chi">选择所有路径依附于/AAA/CCC/DDD的元素</p>
	</example>
	<example path="/*/*/*/BBB">
	        <p lang="ita">Selezione di tutti gli elementi BBB che possiedono 3 progenitori.</p>
		<p lang="eng">Select all elements BBB which have 3 ancestors</p>
		<p lang="ger">Wähle alle BBB Elemente aus, die 3 Vorfahren haben</p>
		<p lang="cze">Vyber všechny elementy BBB, které mají právě tři předky</p>
		<p lang="fre">Sélectionne tous les éléments BBB qui ont trois ancêtres</p>
		<p lang="dut">Selecteert alle BBB elementen die 3 voorouders hebben</p>
		<p lang="spa">Selecciona todos los elementos BBB incluidos en exactamente 3 ancestros</p>
		<p lang="rus">Будут выбраны все элементы ВВВ, имеющие трех предков</p>
		<p lang="chi">选择所有的有3个祖先元素的BBB元素</p>
	</example>
	<example path="//*">
	        <p lang="ita">Selezione di tutti gli elementi.</p>
		<p lang="eng">Select all elements</p>
		<p lang="ger">Wähle alle Elemente aus</p>
		<p lang="cze">Vyber všechny elementy</p>
		<p lang="fre">Sélectionne tous les éléments</p>
		<p lang="dut">Selecteert alle elementen</p>
		<p lang="spa">Selecciona todos los elementos</p>
		<p lang="rus">Будут выбраны все элементы</p>
		<p lang="chi">选择所有元素</p>
	</example>
</XPathTutorial>

<XPathTutorial id='4'  creator="nicmila@systinet.com">
	<key>last()</key>
	<key>position()</key>
	<description lang="ita">Le espressioni all'interno di parentesi quadre consentono di specificare ulteriormente la locazione di un elemento. Un valore numerico all'interno delle parentesi quadre consente di specificare la posizione di un elemento all'interno dell'insieme selezionato. La funzione last() seleziona l'ultimo elemento dell'insieme.</description>
	<description lang="eng">Expresion in square brackets can further specify an element. A number in the brackets gives the position of the element in the selected set. The function last() selects the last element in the selection.</description>
	<description lang="ger">Ausdrücke in eckigen Klammern können weiterhin ein Element spezifizieren. Eine Zahl in eckigen Klammern gibt die Position eines Elements in einer ausgewählten Menge an. Die Funktion last() wählt das letzte Element einer ausgewählten Menge aus.</description>
	<description lang="cze">
Výraz v hranatých závorkách může specifikovat další podmínky.
Číslo v hranatých závorkách určuje pozici elementu ve vybraném
souboru elementů.
Funkce "last()" ("poslední") vybírá poslední element ve výběru.</description>
	<description lang="fre">
Une expression entre crochets peut spécifier plus précisément un élément.  Un nombre entre crochets donne la position d'un élément dans le jeu sélectionné. La fonction last sélectionne le dernier élément du jeu
</description>
	<description lang="dut">Een beschrijving tussen vierkante haken kan een element meer specifïen. Een nummer tussen de haken geeft de positie van het element aan in het geselecteerde path. De functie last() selecteert het laatste element van de selectie.</description>
	<description lang="spa">Una expresión entre corchetes permite precisar la 
   especificación de un elemento. Un número dentro de los corchetes representa 
   la posición del elemento en el conjunto seleccionado. La función last() 
   selecciona el último elemento en la selección.</description>
	<description lang="rus">Выражение в квадратных скобках позволяет задавать более четкие критерии для элемента. Так число в квадратных скобках обозначает позицию элемента в выбранном множестве. Функция last() позволяет указать последний элемент в выборке.</description>
	<description lang="chi">方块号里的表达式可以进一步的指定元素, 其中数字表示元素在选择集里的位置, 而last()函数则表示选择集中的最后一个元素.</description>
	<source>
		<AAA>
			<BBB/>
			<BBB/>
			<BBB/>
			<BBB/>
		</AAA>
	</source>
	<example path="/AAA/BBB[1]">
	        <p lang="ita">Selezione del primo figlio BBB dell'elemento AAA</p>
		<p lang="eng">Select the first BBB child of element AAA</p>
		<p lang="ger">Wähle das erste BBB Kind des AAA Elements aus</p>
		<p lang="cze">Vyber prvního přímého potomka BBB elementu AAA</p>
		<p lang="fre">Sélectionne le premier élément BBB, fils de l'élément racine AAA</p>
		<p lang="dut">Selecteert het eerste BBB kind van het AAA element</p>
		<p lang="spa">Selecciona el primer hijo BBB del elemento AAA</p>
		<p lang="rus">Будет выбран первый потомок BBB элемента AAA</p>
		<p lang="chi">选择AAA的第一个BBB子元素</p>
	</example>
	<example path="/AAA/BBB[last()]">
	        <p lang="ita">Selezione dell'ultimo figlio BBB dell'elemento AAA</p>
		<p lang="eng">Select the last BBB child of element AAA</p>
		<p lang="ger">Wähle das letzte BBB Kind des AAA Elements aus</p>
		<p lang="cze">Vyber posledního přímého potomka BBB elementu AAA</p>
		<p lang="fre">Sélectionne le dernier élément BBB, fils de l'élément racine AAA</p>
		<p lang="dut">Selecteert het laatste BBB kind van het AAA element</p>
		<p lang="spa">Selecciona el último hijo BBB del elemento AAA</p>
		<p lang="rus">Будет выбран последний потомок BBB элемента AAA</p>
		<p lang="chi">选择AAA的最后一个BBB子元素</p>
	</example>
</XPathTutorial>

<XPathTutorial id='5'  creator="nicmila@systinet.com">
	<key>attributes</key>
	<key>@</key>
	<key>not</key>
	<description lang="ita">Gli attributi sono preceduti dal prefisso @</description>
	<description lang="eng">Attributes are specified by @ prefix.</description>
	<description lang="ger">Attribute werden mittels eines @ Präfixes spezifiziert.</description>
	<description lang="cze">
Atributy jsou specifikovány pomocí prefixu "@".</description>
	<description lang="fre">
Les attributs sont spécifiés par le prefixe @.
</description>
	<description lang="dut">Attributen worden gespecifïeerd met het @ voorvoegsel.</description>
	<description lang="spa">Los atributos se especifican con el símbolo prefijo '@'.</description>
	<description lang="rus">Атрибуты определяются префиксом @.</description>
	<desription lang="chi">属性通过前缀 @ 来指定</desription>
	<source>
		<AAA>
			<BBB id="b1"/>
			<BBB id="b2"/>
			<BBB name="bbb"/>
			<BBB/>
		</AAA>
	</source>
	<example path="//@id">
	        <p lang="ita">Selezione di tutti gli attributi id.</p>
		<p lang="eng">Select all attributes @id</p>
		<p lang="ger">Wähle alle "id" Attribute aus</p>
		<p lang="cze">Vyber všechny atributy @id</p>
		<p lang="fre">Sélectionne tous les attributs id</p>
		<p lang="dut">Selecteert alle id attributen</p>
		<p lang="spa">Selecciona todos los atributos 'id'</p>
		<p lang="rus">Выбираются все атрибуты @id</p>
		<p lang="chi">选择所有的id属性</p>
	</example>
	<example path="//BBB[@id]">
	        <p lang="ita">Selezione degli elementi BBB che possiedono l'attributo id.</p>
		<p lang="eng">Select BBB elements which have attribute id</p>
		<p lang="ger">Wähle jene BBB Elemente aus, die ein Attribut "id" haben</p>
		<p lang="cze">Vyber všechny elementy BBB, které mají atribut "id"</p>
		<p lang="fre">Sélectionne tous BBB qui ont un attribut id</p>
		<p lang="dut">Selecteert alle BBB elementen met een id attribuut</p>
		<p lang="spa">Selecciona los elementos BBB que contienen un atributo 'id'</p>
		<p lang="rus">Выбираются элементы BBB, имеющие атрибут id</p>
		<p lang="chi">选择有id属性的BBB元素</p>
	</example>
	<example path="//BBB[@name]">
	        <p lang="ita">Selezione degli elementi BBB che possiedono l'attributo name.</p>
		<p lang="eng">Select BBB elements which have attribute name</p>
		<p lang="ger">Wähle jene BBB Elemente aus, die das Attribut "name" enthalten</p>
		<p lang="cze">Vyber všechny elementy BBB, které mají atribut "name"</p>
		<p lang="fre">Sélectionne tous BBB qui ont un attribut name</p>
		<p lang="dut">Selecteert alle BBB elementen met het name atribuut</p>
		<p lang="spa">Selecciona los elementos BBB que contienen un atributo 'name'</p>
		<p lang="rus">Выбираются элементы BBB, имеющие атрибут name</p>
		<p lang="chi">选择有name属性的BBB元素</p>
	</example>
	<example path="//BBB[@*]">
	        <p lang="ita">Selezione degli elementi BBB che possiedono almeno un attributo.</p>
		<p lang="eng">Select BBB elements which have any attribute</p>
		<p lang="ger">Wähle jene BBB Elemente aus, die ein beliebiges Attribut haben</p>
		<p lang="cze">Vyber všechny elementy BBB, které mají jakýkoli atribut</p>
		<p lang="fre">Sélectionne tous BBB qui ont un attribut</p>
		<p lang="dut">Selecteert alle BBB elementen die een attribuut hebben</p>
		<p lang="spa">Selecciona los elementos BBB que contienen algún atributo</p>
		<p lang="rus">Выбираются элементы BBB, имеющие хоть какой-нибудь атрибут</p>
		<p lang="chi">选择有任意属性的BBB元素</p>
	</example>
	<example path="//BBB[not(@*)]">
	        <p lang="ita">Selezione degli elementi BBB che non possiedono attributi.</p>
		<p lang="eng">Select BBB elements without an attribute</p>
		<p lang="ger">Wähle jene BBB Elemente aus, die kein Attribut haben</p>
		<p lang="cze">Vyber všechny elementy BBB, které nemají žádný atribut</p>
		<p lang="fre">Sélectionne tous BBB qui n'ont pas d'attribut</p>
		<p lang="dut">Selecteert alle BBB elementen zonder een attribuut</p>
		<p lang="spa">Selecciona los elementos BBB que no contienen atributos</p>
		<p lang="rus">Выбираются элементы BBB, не имеющие ни одного атрибута</p>
		<p lang="chi">选择没有属性的BBB元素</p>
	</example>
</XPathTutorial>

<XPathTutorial id='6'  creator="nicmila@systinet.com">
	<key>normalize-space()</key>
	<key>attributes</key>
	<key>@</key>
	<description lang="ita">I valori degli attributi possono essere utilizzati come criteri di selezione. La funzione normalize-space() rimuove gli spazi precedenti e successivi e sostituisce con un singolo spazio sequenze di caratteri di spaziatura.</description>
	<description lang="eng">Values of attributes can be used as selection criteria. Function normalize-space removes leading and trailing spaces and replaces sequences of whitespace characters by a single space.</description>
	<description lang="ger">Attributwerte können als Auswahlkriterien verwendet werden. Die Funktion "normalize-space()" entfernt voranstehende und nachkommende Leerzeichen und ersetzt Leerzeichenfolgen durch ein einfaches Leerzeichen.</description>
	<description lang="cze">
Hodnoty atributů mohou být použity jako kritérium pro výběr.
Funkce "normalize-space" odstraňuje počáteční a koncové mezery
a nahrazuje sekvence "whitespace" znaků jedinou mezerou.</description>
	<description lang="fre">
Les valeurs d'attributs peuvent être utilisées comme critère de sélection. La fonction normalize-space supprime les espaces de début et de fin puis remplace les séquences d'espaces blancs par un seul espace.
</description>
	<description lang="dut">Attribuutwaarden kunnen gebruikt worden als selectie criteria. De functie normalize-space verwijdert voorloop spaties en vervangt spatie reeksen met een enkele spatie.</description>
	<description lang="spa">Los valores de los atributos pueden ser utilizados 
   como criterio de selección. La función 'normalize-space' elimina los espacios 
   al principio y al final, así como tambien remplaza las secuencias de blancos 
   por un solo espacio.</description>
	<description lang="rus">Значения атрибутов могут служить критерием при выборке. Функция normalize-space() удаляет пробелы в начале и конце параметра, а все последовательности пробельных символов заменяет одиночным пробелом.</description>
	<description lang="chi">属性的值可以被用来作为选择的准则, normalize-space函数删除了前部和尾部的空格, 并且把连续的空格串替换为一个单一的空格</description>
	<source>
		<AAA>
			<BBB id="b1"/>
			<BBB name=" bbb "/>
			<BBB name="bbb"/>
		</AAA>
	</source>
	<example path="//BBB[@id='b1']">
	        <p lang="ita">Selezione degli elementi BBB per i quali l'attributo id ha valore b1.</p>
		<p lang="eng">Select BBB elements which have attribute id with value b1</p>
		<p lang="ger">Wähle alle BBB Elemente aus, die ein Attribut "id" mit dem Wert "b1" haben</p>
		<p lang="cze">Vyber elementy BBB, jejichž atribut "id" má hodnotu "b1"</p>
		<p lang="fre">Sélectionne tous les éléments BBB ayant un attribut id dont la valeur est b1</p>
		<p lang="dut">Selecteert de BBB elementen die het attribuut id bevatten en b1 als attribuutwaarde hebben</p>
		<p lang="spa">Selecciona los elementos BBB cuyo atributo 'id' tiene por valor 'b1'</p>
		<p lang="rus">Выбираются элементы BBB, имеющие атрибут id со значением b1</p>
		<p lang="chi">选择含有属性id且其值为'b1'的BBB元素</p>
	</example>
	<example path="//BBB[@name='bbb']">
                <p lang="ita">Selezione degli elementi BBB per i quali l'attributo name ha valore bbb.</p>
		<p lang="eng">Select BBB elements which have attribute name with value 'bbb'</p>
		<p lang="ger">Wähle alle BBB Elemente aus, die ein Attribut "name" mit dem Wert "bbb" haben</p>
		<p lang="cze">Vyber elementy BBB, jejichž atribut "name" má hodnotu "bbb"</p>
		<p lang="fre">Sélectionne tous les éléments BBB ayant un attribut name dont la valeur est bbb</p>
		<p lang="dut">Selecteert de BBB elementen die het attribuut name bevatten en als attribuutwaarde bbb hebben</p>
		<p lang="spa">Selecciona los elementos BBB cuyo atributo 'name' tiene por valor 'bbb'</p>
		<p lang="rus">Выбираются элементы BBB, имеющие атрибут name со значением 'bbb'</p>
		<p lang="chi">选择含有属性name且其值为'bbb'的BBB元素</p>
	</example>
	<example path="//BBB[normalize-space(@name)='bbb']">
	        <p lang="ita">Selezione degli elementi BBB per i quali l'attributo name ha valore bbb: spazi precedenti e successivi vengono rimossi prima del confronto.</p>
		<p lang="eng">Select BBB elements which have attribute name with value bbb, leading and trailing spaces are removed before comparison</p>
		<p lang="ger">Wähle die BBB Elemente aus, die ein Attribut "name" mit dem Wert "bbb" haben. Voranstehende und nachkommende Leerzeichen werden vor dem Vergleich entfernt</p>
		<p lang="cze">
Vyber elementy BBB, které mají atribut "name" s hodnotou "bbb", přičemž
koncové a počáteční mezery jsou před porovnáním odstraněny.</p>
		<p lang="fre">Sélectionne tous les éléments BBB ayant un attribut name dont la valeur est bbb. Les espaces de début de de fin sont supprimés avant la comparaison</p>
		<p lang="dut">Selecteert de BBB elementen die het name attribuut bevatten met de waarde bbb na alle voorloop spaties verijdert te hebben</p>
		<p lang="spa">Selecciona los elementos BBB cuyo atributo 'name' tiene por valor 'bbb' una vez eliminados los espacios al principio y al final</p>
		<p lang="rus">Выбираются элементы BBB, имеющие атрибут name со значением, которое после нормализации будет идентично bbb</p>
		<p lang="chi">选择含有属性name且其值(在用normalize-space函数去掉前后空格后)为'bbb'的BBB元素</p>
	</example>
</XPathTutorial>

<XPathTutorial id='7'  creator="nicmila@systinet.com">
	<key>count()</key>
	<description lang="ita">La funzione count() calcola il numero degli elementi selezionati.</description>
	<description lang="eng">Function count() counts the number of selected elements </description>
	<description lang="ger">Die Funktion count() zählt die Anzahlt der ausgewählten Elemente</description>
	<description lang="cze">
Funkce count() vrátí počet vybraných elementů </description>
	<description lang="fre">
La fonction count() compte le nombre d'éléments sélectionnés.
</description>
	<description lang="dut">Functie count() telt het aantal geselecteerde elementen</description>
	<description lang="spa">La función count() cuenta el número de elementos seleccionados</description>
	<description lang="rus">Функция count() возвращает число элементов в указанном множестве.</description>
	<description lang="chi">count()函数可以计数所选元素的个数</description>
	<source>
		<AAA>
			<CCC>
				<BBB/>
				<BBB/>
				<BBB/>
			</CCC>
			<DDD>
				<BBB/>
				<BBB/>
			</DDD>
			<EEE>
				<CCC/>
				<DDD/>
			</EEE>
		</AAA>
	</source>
	<example path="//*[count(BBB)=2]">
	        <p lang="ita">Selezione degli elementi che possiedono due figli BBB</p>
		<p lang="eng">Select elements which have two children BBB</p>
		<p lang="ger">Wähle jene Elemente aus, die zwei BBB Kinder haben</p>
		<p lang="cze">Vyber elementy, které mají právě dva přímé potomky BBB</p>
		<p lang="fre">Sélectionne les éléments ayant deux enfants BBB </p>
		<p lang="dut">Selecteert alle elementen die twee BBB kinderen bevatten</p>
		<p lang="spa">Selecciona los elementos que contienen dos hijos BBB</p>
		<p lang="rus">Выбираются элементы, имеющие два дочерних элемента 
BBB</p>
       <p lang="chi">选择含有2个BBB子元素的元素</p>
	</example>
	<example path="//*[count(*)=2]">
	        <p lang="ita">Selezione degli elementi che possiedono 2 figli.</p>
		<p lang="eng">Select elements which have 2 children</p>
		<p lang="ger">Wähle jene Elemente aus, die zwei Kinder haben</p>
		<p lang="cze">Vyber elementy, které mají právě dva přímé potomky</p>
		<p lang="fre">Sélectionne les éléments ayant deux enfants</p>
		<p lang="dut">Selecteert alle elementen die twee kinderen hebben</p>
		<p lang="spa">Selecciona elementos con dos hijos</p>
		<p lang="rus">Выбираются элементы, имеющие два произвольных дочерних элемента</p>
		<p lang="chi">选择含有2个子元素的元素</p>
	</example>
	<example path="//*[count(*)=3]">
	        <p lang="ita">Selezione degli elementi che possiedono 3 figli.</p>
		<p lang="eng">Select elements which have 3 children</p>
		<p lang="ger">Wähle jene Elemente aus, die drei Kinder haben</p>
		<p lang="cze">Vyber elementy, které mají právě tři přímé potomky</p>
		<p lang="fre">Sélectionne les éléments ayant trois enfants</p>
		<p lang="dut">Selecteert alle elementen die drie kinderen hebben</p>
		<p lang="spa">Selecciona elementos con 3 hijos</p>
		<p lang="rus">Выбираются элементы, имеющие три произвольных дочерних элемента</p>
		<p lang="chi">选择含有3个子元素的元素</p>
	</example>
</XPathTutorial>

<XPathTutorial id='8'  creator="nicmila@systinet.com">
	<key>name()</key>
	<key>starts-with()</key>
	<key>contains()</key>
	<description lang="ita">La funzione name() restituisce il nome dell'elemento, la funzione starts-with() ritorna true se la stringa utilizzata come primo argomento inizia con la stringa utilizzata come secondo argomento e, infine, la funzione contains() restituisce true se la stringa utilizzata come primo argomento contiene la stringa passata come secondo argomento.</description>
	<description lang="eng">Function name() returns name of the element, the starts-with function returns true if the first argument string starts with the second argument string, and the contains function returns true if the first argument string contains the second argument string.</description>
	<description lang="ger">Die Funktion "name()" gibt den Namen des Elements zurück. Die Funktion "starts-with()" gibt "true" zurück falls der String des ersten Arguments mit dem String des zweiten Arguments startet. Die Funktion "contains()" gibt "true" zurück falls der String des ersten Arguments den String des zweiten Arguments beinhaltet.</description>
	<description lang="cze">
Funkce name() vrací jméno elementu, funkce "starts-with"
vrací hodnotu "true", pokud první argument začíná řetězcem, který je uveden
jako druhý argument.
Funkce "contains" vrací hodnotu "true", pokud 
 první argument obsahuje řetězec, který je uveden
jako druhý argument.</description>
	<description lang="fre">
La fonction name() retourne le nom de l'élément, 
la fonction start-with retourne vrai si la chaîne du premier argument commence par celle du deuxième 
et la fonction contains retourne vrai si la chaîne du premier argument contient celle du deuxième
</description>
	<description lang="dut">Functie name() geeft de naam van het element weer, de functie starts-with wordt van toepassing als het begin van het eerste argument gelijk is aan het tweede argument en de functie contains wordt van toepassing als het eerste argument het tweede argument bevat</description>
	<description lang="spa">La función name() produce el nombre del elemento 
   seleccionado, la función 'starts-with' es verdadera cuando la cadena de 
   caracteres pasada en primer argumento tiene como prefijo al segundo argumento.
   Lo función 'contains' es verdadera cuando la cadena del primer 
   argumento contiene al segundo argumento.</description>
	<description lang="rus">Функция name() возвращает имя элемента. Функция starts-with() возвращает истину, если строка первого аргумента начинается строкой второго аргумента. Функция contains() возвращает истину, если строка из первого аргумента содержит строку из второго.</description>
	<description lang="chi">name()函数返回元素的名称, start-with()函数在该函数的第一个参数字符串是以第二个参数字符开始的情况返回true, contains()函数当其第一个字符串参数包含有第二个字符串参数时返回true.</description>
	<source>
		<AAA>
			<BCC>
				<BBB/>
				<BBB/>
				<BBB/>
			</BCC>
			<DDB>
				<BBB/>
				<BBB/>
			</DDB>
			<BEC>
				<CCC/>
				<DBD/>
			</BEC>
		</AAA>
	</source>
	<example path="//*[name()='BBB']">
	        <p lang="ita">Selezione di tutti gli elementi di nome BBB: equivalente a //BBB</p>
		<p lang="eng">Select all elements with name BBB, equivalent with //BBB</p>
		<p lang="ger">Wähle alle Elemente mit dem Namen BBB aus. Entspricht //BBB</p>
		<p lang="cze">Vyber všechny elementy, které se jmenují BBB, ekvivalent k //BBB</p>
		<p lang="dut">Selecteert alle BBB elementen, //BBB geeft hetzelfde resultaat weer</p>
		<p lang="spa">Selecciona todos los elementos BBB, equivalente a //BBB</p>
		<p lang="rus">Выбираются все элементы с именем BBB; эквивалентно пути //BBB</p>
		<p lang="chi">选择所有名称为BBB的元素(这里等价于//BBB)</p>
	</example>
	<example path="//*[starts-with(name(),'B')]">
	        <p lang="ita">Selezione di tutti gli elementi il cui nome inizia con la lettera B.</p>
		<p lang="eng">Select all elements name of which starts with letter B</p>
		<p lang="ger">Wähle alle Elemente aus, deren Name mit dem Buchstaben B beginnt</p>
		<p lang="cze">Vyber všechny elementy, jejichž jméno začíná písmenem B</p>
		<p lang="dut">Selecteert alle elementen waarvan de naam begint met B</p>
		<p lang="spa">Selecciona todos los elementos cuyo nombre se inicie
      con la letra B</p>
		<p lang="rus">Выбираются все элементы, имя которых начинается с B</p>
		<p lang="chi">选择所有名称以"B"起始的元素</p>
	</example>
	<example path="//*[contains(name(),'C')]">
	        <p lang="ita">Selezione di tutti gli elementi il cui nome contiene la lettera C.</p>
		<p lang="eng">Select all elements name of which contain letter C</p>
		<p lang="ger">Wähle alle Elemente aus, deren Namen den Buchstaben C enthält</p>
		<p lang="cze">Vyber všechny elementy, jejichž jméno obsahuje písmeno C</p>
		<p lang="dut">Selecteert alle elementen die C in hun naam hebben</p>
		<p lang="spa">Selecciona todos los elementos cuyo nombre contenga
      la letra C</p>
		<p lang="rus">Выбираются все элементы, имя которых содержит C</p>
		<p lang="chi">选择所有名称包含"C"的元素</p>
	</example>
</XPathTutorial>

<XPathTutorial id='9'  creator="nicmila@systinet.com">
	<key>string-length()</key>
	<key>name()</key>
	<key>&amp;lt;</key>
	<key>&amp;gt;</key>
	<description lang="ita">La funzione string-length() restituisce il numero di caratteri presenti nella stringa. Dovete utilizzre &amp;lt; in sostituzione di &lt; e &amp;gt; al posto di &gt; .</description>
	<description lang="eng">The string-length function returns the number of characters in the string. You must use &amp;lt; as a substitute for &lt;  and &amp;gt; as a substitute for &gt; .</description>
	<description lang="ger">Die Funktion "string-length()" liefert die Anzahl der Zeichen eines Strings zurück. Man muss &amp;lt; als Austausch für &lt; und &amp;gt; als Austausch für &gt; verwenden.</description>
	<description lang="cze">
Funkce "string-length" vrací počet znaků v řetězci.
Musíte použít &amp;lt; jako náhražku pro &lt; (menší než)
a &amp;gt; jako náhražku pro &gt; (větší než).</description>
	<description lang="fre">
La fonction string-length retourne le nombre de caractères dans une chaîne. Vous devez utiliser &amp;lt; comme substitutif de &lt; et &amp;gt comme substitutif de &gt;
</description>
	<description lang="dut">De functie string-length geeft het aantal tekens weer van een tekenreeks. U moet &amp;lt; gebruiken als vervanging voor &lt; en &amp;gt; als vervanging voor &gt;</description>
	<description lang="spa">La función 'string-length' produce el número de 
   caracteres de su argumento. Se debe utilizar &amp;lt; en remplazo de &lt;  
   y &amp;gt; en remplazo de &gt;.</description>
	<description lang="rus">Функция string-length() возвращает число символов в строке. Следует использовать &amp;lt; вместо &lt;, так как символ '&lt;' зарезервирован для нужд разметки.</description>
	<description lang="chi">string-length函数返回字符串的字符数,你应该用&amp;lt;替代&lt;, 用&amp;gt;代替&gt;</description>
	<source>
		<AAA>
			<Q/>
			<SSSS/>
			<BB/>
			<CCC/>
			<DDDDDDDD/>
			<EEEE/>
		</AAA>
	</source>
	<example path="//*[string-length(name()) = 3]">
	        <p lang="ita">Selezione degli elementi il cui nome &#xE8; composto da 3 caratteri.</p>
		<p lang="eng">Select elements with three-letter name</p>
		<p lang="ger">Wähle alle Elemente aus, deren Namen drei Buchstaben enthält</p>
		<p lang="cze">Vyber elementy, které mají třípísmenné jméno</p>
		<p lang="dut">Selecteert alle elementen met een drieletterige naam</p>
		<p lang="spa">Selecciona elementos con tres caracteres en su nombre</p>
		<p lang="rus">Выбираются все элементы, имя которых состоит из трех символов</p>
		<p lang="chi">选择名字长度为3的元素</p>
	</example>
	<example path="//*[string-length(name()) &lt; 3]">
	        <p lang="ita">Selezione degli elementi il cui nome &#xE8; composto da 1 o 2 caratteri.</p>
		<p lang="eng">Select elements name of which  has one or two characters</p>
		<p lang="ger">Wähle alle Elemente aus, deren Namen ein oder zwei Buchstaben hat</p>
		<p lang="cze">Vyber elementy, jejichž jméno má jeden nebo dva znaky</p>
		<p lang="dut">Selecteert alle elementen die een naam hebben met een of twee tekens</p>
		<p lang="spa">Selecciona elementos cuyo nombre contenga uno o dos caracteres</p>
		<p lang="rus">Выбираются все элементы, имя которых состоит из двух или одного символа</p>
		<p lang="chi">选择名字长度小于3的元素</p>
	</example>
	<example path="//*[string-length(name()) &gt; 3]">
	        <p lang="ita">Selezione degli elementi il cui nome &#xE8; composto da pi&#xF9; di 3 caratteri.</p>
		<p lang="eng">Select elements with name longer than three characters</p>
		<p lang="ger">Wähle alle Elemente aus, deren Name mehr als drei Zeichen enthält</p>
		<p lang="cze">Vyber elementy se jménem delším než tři znaky</p>
		<p lang="dut">Selecteert alle elementen die een naam hebben die langer is dan drie tekens</p>
		<p lang="spa">Selecciona elementos cuyo nombre tenga más de tres caracteres</p>
		<p lang="rus">Выбираются все элементы, имя которых состоит более чем из трех символов</p>
		<p lang="chi">选择名字长度大于3的元素</p>
	</example>
</XPathTutorial>

</xm_sources>